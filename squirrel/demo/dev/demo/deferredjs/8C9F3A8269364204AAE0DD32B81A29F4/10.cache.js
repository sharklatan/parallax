function xjb(){}
function Gjb(){}
function Djb(){}
function Ljb(){}
function Kjb(){}
function Pjb(){}
function Ojb(){}
function llb(){}
function wlb(){}
function tlb(){}
function Blb(){}
function Alb(){}
function Flb(){}
function Elb(){}
function Utb(){}
function jvb(){}
function ovb(){}
function rvb(){}
function Ivb(){}
function Mvb(){}
function yEb(){}
function Jpb(a,b){a.r=b}
function AEb(){myb.call(this)}
function svb(){cub.call(this,new nub)}
function yjb(){yib.call(this,(Cjb(),Bjb))}
function mlb(){yib.call(this,(slb(),rlb))}
function kvb(a){cub.call(this,a);bub(this,a.a)}
function pvb(){nub.call(this);this.a=(Zub(),Yub)}
function Cjb(){Cjb=LHb;Bjb=new Gjb}
function Sjb(){Sjb=LHb;Ejb=new Ljb}
function Tjb(){Tjb=LHb;Fjb=new Pjb}
function slb(){slb=LHb;rlb=new wlb}
function Ilb(){Ilb=LHb;ulb=new Blb}
function Jlb(){Jlb=LHb;vlb=new Flb}
function Vtb(){Ktb.call(this,16777215);this.b=1;this.a=0;new jrb(0,0,0)}
function Jvb(a){iub.call(this,a);this.a=a.a;this.b=a.c;this.d=a.f;this.c=a.e;this.j=null;this.g=a.b;bub(this,a.d)}
function Nvb(){pub.call(this);this.a=new Wob(328965);this.f=new Wob(1118481);this.c=new Wob(0);this.b=(qnb(),pnb);this.d=(Zub(),Yub)}
function zEb(){var a,b,c,d,e,f,g,i;a=ag($doc,U0b);a.width=256;a.height=256;b=a.getContext(V0b);d=b.getImageData(0,0,256,256);i=0;for(c=0,e=0,f=d.data.length;c<f;c+=4,++e){g=e%64;i=g==0?i+1:i;d.data[c]=255;d.data[c+1]=255;d.data[c+2]=255;d.data[c+3]=xp(Math.floor(g^i))}b.putImageData(d,0,0);return a}
var O0b='#ifndef PHONG_PER_PIXEL\r\n\r\n\t#if MAX_POINT_LIGHTS > 0\r\n\t\tfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\r\n\t\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\r\n\t\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\r\n\r\n\t\t\tfloat lDistance = 1.0;\r\n\t\t\tif ( pointLightDistance[ i ] > 0.0 )\r\n\t\t\t\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\r\n\t\t\t\r\n\t\t\tvPointLight[ i ] = vec4( lVector, lDistance );\r\n\t\t}\r\n\r\n\t#endif\r\n\r\n\t#if MAX_SPOT_LIGHTS > 0\r\n\t\tfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\r\n\t\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\r\n\t\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\r\n\r\n\t\t\tfloat lDistance = 1.0;\r\n\t\t\tif ( spotLightDistance[ i ] > 0.0 )\r\n\t\t\t\tlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\r\n\t\t\t\r\n\t\t\tvSpotLight[ i ] = vec4( lVector, lDistance );\r\n\r\n\t\t}\r\n\r\n\t#endif\r\n\r\n#endif\r\n\r\n#if MAX_SPOT_LIGHTS > 0\r\n\tvWorldPosition = mPosition.xyz;\r\n#endif',H0b='#ifndef PHONG_PER_PIXEL\r\n\r\n\t#if MAX_POINT_LIGHTS > 0\r\n\t\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\r\n\t\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\r\n\r\n\t\tvarying vec4 vPointLight[ MAX_POINT_LIGHTS ];\r\n\t#endif\r\n\r\n\t#if MAX_SPOT_LIGHTS > 0\r\n\t\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\r\n\t\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\r\n\r\n\t\tvarying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\r\n\t#endif\r\n\r\n#endif\r\n\r\n#if MAX_SPOT_LIGHTS > 0\r\n\tvarying vec3 vWorldPosition;\r\n#endif',g1b='MaterialsCanvas2D$DemoScene',d1b='MeshDepthMaterial$MeshDepthMaterialOptions',e1b='MeshFaceMaterial',f1b='MeshPhongMaterial$MeshPhongMaterialOptions',W0b='ShaderDepth',X0b='ShaderDepth_Resources_default_StaticClientBundleGenerator',Y0b='ShaderDepth_Resources_default_StaticClientBundleGenerator$1',Z0b='ShaderDepth_Resources_default_StaticClientBundleGenerator$2',$0b='ShaderPhong',_0b='ShaderPhong_Resources_default_StaticClientBundleGenerator',a1b='ShaderPhong_Resources_default_StaticClientBundleGenerator$1',b1b='ShaderPhong_Resources_default_StaticClientBundleGenerator$2',m0b='mFar',l0b='mNear',t0b='shininess',s0b='specular',o0b='uniform float mNear;\r\nuniform float mFar;\r\nuniform float opacity;\r\n\r\nvoid main() {\r\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\r\n\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\r\n\tgl_FragColor = vec4( vec3( color ), opacity );\r\n}\r\n',y0b='uniform vec3 ambientLightColor;\r\n\r\n#if MAX_DIR_LIGHTS > 0\r\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\r\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\r\n#endif\r\n\r\n#if MAX_POINT_LIGHTS > 0\r\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\r\n\r\n\t#ifdef PHONG_PER_PIXEL\r\n\t\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\r\n\t\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\r\n\t#else\r\n\t\tvarying vec4 vPointLight[ MAX_POINT_LIGHTS ];\r\n\t#endif\r\n#endif\r\n\r\n#if MAX_SPOT_LIGHTS > 0\r\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\r\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\r\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\r\n\tuniform float spotLightAngle[ MAX_SPOT_LIGHTS ];\r\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\r\n\r\n\t#ifdef PHONG_PER_PIXEL\r\n\t\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\r\n\t#else\r\n\t\tvarying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\r\n\t#endif\r\n\r\n\tvarying vec3 vWorldPosition;\r\n\r\n#endif\r\n\r\n#ifdef WRAP_AROUND\r\n\tuniform vec3 wrapRGB;\r\n#endif\r\n\r\nvarying vec3 vViewPosition;\r\nvarying vec3 vNormal;',S0b='uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\nuniform vec3 ambient;\r\nuniform vec3 emissive;\r\nuniform vec3 specular;\r\nuniform float shininess;\r\n\r\n//[*]\r\n\t\t\t\r\nvoid main() {\r\n\tgl_FragColor = vec4( vec3 ( 1.0 ), opacity );\r\n\t\t\t\t\r\n//[*]\r\n\t\t\t\t\r\n}\r\n',T0b='varying vec3 vViewPosition;\r\nvarying vec3 vNormal;\r\n\r\n//[*]\r\n\t\t\t\r\nvoid main() {\r\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\r\n\t\t\t\t\r\n//[*]\r\n\t\t\t\r\n#ifndef USE_ENVMAP\r\n\tvec4 mPosition = objectMatrix * vec4( position, 1.0 );\r\n#endif\r\n\r\nvViewPosition = -mvPosition.xyz;\r\n\t\t\t\r\n//[*]\r\n\t\t\t\r\nvNormal = transformedNormal;\r\n\r\n//[*]\r\n\r\n}\r\n',A0b='vec3 normal = normalize( vNormal );\r\nvec3 viewPosition = normalize( vViewPosition );\r\n\r\n#ifdef DOUBLE_SIDED\r\n\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\r\n#endif\r\n\r\n#if MAX_POINT_LIGHTS > 0\r\n\tvec3 pointDiffuse  = vec3( 0.0 );\r\n\tvec3 pointSpecular = vec3( 0.0 );\r\n\r\n\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\r\n\t\t#ifdef PHONG_PER_PIXEL\r\n\t\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\r\n\t\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\r\n\r\n\t\t\tfloat lDistance = 1.0;\r\n\t\t\tif ( pointLightDistance[ i ] > 0.0 )\r\n\t\t\t\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\r\n\r\n\t\t\tlVector = normalize( lVector );\r\n\t\t#else\r\n\t\t\tvec3 lVector = normalize( vPointLight[ i ].xyz );\r\n\t\t\tfloat lDistance = vPointLight[ i ].w;\r\n\t\t#endif\r\n\r\n\t\t// diffuse\r\n\r\n\t\tfloat dotProduct = dot( normal, lVector );\r\n\r\n\t\t#ifdef WRAP_AROUND\r\n\t\t\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\r\n\t\t\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\r\n\t\t\tvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\r\n\t\t#else\r\n\t\t\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\r\n\t\t#endif\r\n\r\n\t\tpointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\r\n\r\n\t\t// specular\r\n\r\n\t\tvec3 pointHalfVector = normalize( lVector + viewPosition );\r\n\t\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\r\n\t\tfloat pointSpecularWeight = max( pow( pointDotNormalHalf, shininess ), 0.0 );\r\n\r\n\t\t#ifdef PHYSICALLY_BASED_SHADING\r\n\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\t\t\tfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\r\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );\r\n\t\t\tpointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\r\n\t\t#else\r\n\t\t\tpointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;\r\n\t\t#endif\r\n\t}\r\n\r\n#endif\r\n\r\n#if MAX_SPOT_LIGHTS > 0\r\n\tvec3 spotDiffuse  = vec3( 0.0 );\r\n\tvec3 spotSpecular = vec3( 0.0 );\r\n\r\n\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\r\n\t\t#ifdef PHONG_PER_PIXEL\r\n\t\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\r\n\t\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\r\n\r\n\t\t\tfloat lDistance = 1.0;\r\n\t\t\tif ( spotLightDistance[ i ] > 0.0 )\r\n\t\t\t\tlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\r\n\r\n\t\t\tlVector = normalize( lVector );\r\n\t\t#else\r\n\t\t\tvec3 lVector = normalize( vSpotLight[ i ].xyz );\r\n\t\t\tfloat lDistance = vSpotLight[ i ].w;\r\n\t\t#endif\r\n\r\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\r\n\r\n\t\tif ( spotEffect > spotLightAngle[ i ] ) {\r\n\t\t\tspotEffect = pow( spotEffect, spotLightExponent[ i ] );\r\n\r\n\t\t\t// diffuse\r\n\r\n\t\t\tfloat dotProduct = dot( normal, lVector );\r\n\r\n\t\t\t#ifdef WRAP_AROUND\r\n\t\t\t\tfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\r\n\t\t\t\tfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\r\n\t\t\t\tvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\r\n\t\t\t#else\r\n\t\t\t\tfloat spotDiffuseWeight = max( dotProduct, 0.0 );\r\n\t\t\t#endif\r\n\r\n\t\t\tspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\r\n\r\n\t\t\t// specular\r\n\r\n\t\t\tvec3 spotHalfVector = normalize( lVector + viewPosition );\r\n\t\t\tfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\r\n\t\t\tfloat spotSpecularWeight = max( pow( spotDotNormalHalf, shininess ), 0.0 );\r\n\r\n\t\t\t#ifdef PHYSICALLY_BASED_SHADING\r\n\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\t\t\t\tfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\r\n\t\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );\r\n\t\t\t\tspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\r\n\t\t\t#else\r\n\t\t\t\tspotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;\r\n\t\t\t#endif\r\n\t\t}\r\n\t}\r\n\r\n#endif\r\n\r\n#if MAX_DIR_LIGHTS > 0\r\n\tvec3 dirDiffuse  = vec3( 0.0 );\r\n\tvec3 dirSpecular = vec3( 0.0 );\r\n\r\n\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\r\n\t\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\r\n\t\tvec3 dirVector = normalize( lDirection.xyz );\r\n\r\n\t\t// diffuse\r\n\r\n\t\tfloat dotProduct = dot( normal, dirVector );\r\n\r\n\t\t#ifdef WRAP_AROUND\r\n\t\t\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\r\n\t\t\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\r\n\t\t\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\r\n\t\t#else\r\n\t\t\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\r\n\t\t#endif\r\n\r\n\t\tdirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\r\n\r\n\t\t// specular\r\n\r\n\t\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\r\n\t\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\r\n\t\tfloat dirSpecularWeight = max( pow( dirDotNormalHalf, shininess ), 0.0 );\r\n\r\n\t\t#ifdef PHYSICALLY_BASED_SHADING\r\n\t\t/*\r\n\t\t\t// fresnel term from skin shader\r\n\t\t\tconst float F0 = 0.128;\r\n\t\t\tfloat base = 1.0 - dot( viewPosition, dirHalfVector );\r\n\t\t\tfloat exponential = pow( base, 5.0 );\r\n\t\t\tfloat fresnel = exponential + F0 * ( 1.0 - exponential );\r\n\t\t*/\r\n\r\n\t\t/*\r\n\t\t\t// fresnel term from fresnel shader\r\n\t\t\tconst float mFresnelBias = 0.08;\r\n\t\t\tconst float mFresnelScale = 0.3;\r\n\t\t\tconst float mFresnelPower = 5.0;\r\n\t\t\tfloat fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\r\n\t\t*/\r\n\r\n\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\t\t\tfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\r\n\t\t\t//dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\r\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\r\n\t\t\tdirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\r\n\t\t\r\n\t\t#else\r\n\t\t\tdirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;\r\n\t\t#endif\r\n\t}\r\n\r\n#endif\r\n\r\nvec3 totalDiffuse = vec3( 0.0 );\r\nvec3 totalSpecular = vec3( 0.0 );\r\n\r\n#if MAX_DIR_LIGHTS > 0\r\n\ttotalDiffuse += dirDiffuse;\r\n\ttotalSpecular += dirSpecular;\r\n#endif\r\n\r\n#if MAX_POINT_LIGHTS > 0\r\n\ttotalDiffuse += pointDiffuse;\r\n\ttotalSpecular += pointSpecular;\r\n#endif\r\n\r\n#if MAX_SPOT_LIGHTS > 0\r\n\ttotalDiffuse += spotDiffuse;\r\n\ttotalSpecular += spotSpecular;\r\n#endif\r\n\r\n#ifdef METAL\r\n\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\r\n#else\r\n\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\r\n#endif',p0b='void main() {\r\n\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n}\r\n';_=yjb.prototype=xjb.prototype=new tib;_.gC=function zjb(){return Hw};_.dd=function Ajb(){vib(this,l0b,new Llb((emb(),Slb),new KY(1)));vib(this,m0b,new Llb(Slb,new KY(2000)));vib(this,n0b,new Llb(Slb,new KY(1)))};var Bjb;_=Gjb.prototype=Djb.prototype=new Jb;_.gC=function Hjb(){return Gw};_.gd=function Ijb(){return Sjb(),Ejb};_.hd=function Jjb(){return Tjb(),Fjb};var Ejb=null,Fjb=null;_=Ljb.prototype=Kjb.prototype=new Jb;_.gC=function Mjb(){return Ew};_.Nb=function Njb(){return o0b};_.cM={45:1};_=Pjb.prototype=Ojb.prototype=new Jb;_.gC=function Qjb(){return Fw};_.Nb=function Rjb(){return p0b};_.cM={45:1};_=mlb.prototype=llb.prototype=new tib;_.gC=function nlb(){return Xw};_.dd=function olb(){uib(this,(nmb(),imb));uib(this,jmb);uib(this,kmb);uib(this,mmb);vib(this,q0b,new Llb((emb(),Rlb),new Wob(16777215)));vib(this,r0b,new Llb(Rlb,new Wob(0)));vib(this,s0b,new Llb(Rlb,new Wob(1118481)));vib(this,t0b,new Llb(Slb,new KY(30)));vib(this,u0b,new Llb(amb,new jrb(1,1,1)))};_.ed=function plb(a){var b,c;c=new E2(ip(LA,{79:1,80:1,84:1,95:1},1,[v$b,v0b,w0b,x0b,x$b,y0b,y$b]));b=new E2(ip(LA,{79:1,80:1,84:1,95:1},1,[z0b,A$b,A0b,B0b,B$b,C0b,C$b,D0b,D$b]));wib(this,Cib(a,ip(NA,{79:1,95:1},102,[c,b])))};_.fd=function qlb(a){var b,c,d,e;e=new E2(ip(LA,{79:1,80:1,84:1,95:1},1,[E0b,F0b,G0b,H0b,v$b,I0b,J0b,E$b]));b=new E2(ip(LA,{79:1,80:1,84:1,95:1},1,[K0b,L0b,M0b,F$b]));c=new E2(ip(LA,{79:1,80:1,84:1,95:1},1,[N0b]));d=new E2(ip(LA,{79:1,80:1,84:1,95:1},1,[O0b,P0b,Q0b,R0b,G$b]));xib(this,Cib(a,ip(NA,{79:1,95:1},102,[e,b,c,d])))};var rlb;_=wlb.prototype=tlb.prototype=new Jb;_.gC=function xlb(){return Ww};_.gd=function ylb(){return Ilb(),ulb};_.hd=function zlb(){return Jlb(),vlb};var ulb=null,vlb=null;_=Blb.prototype=Alb.prototype=new Jb;_.gC=function Clb(){return Uw};_.Nb=function Dlb(){return S0b};_.cM={45:1};_=Flb.prototype=Elb.prototype=new Jb;_.gC=function Glb(){return Vw};_.Nb=function Hlb(){return T0b};_.cM={45:1};_=Vtb.prototype=Utb.prototype=new Jtb;_.gC=function Wtb(){return gy};_.cM={146:1,147:1,158:1};_.a=0;_.b=0;_=kvb.prototype=jvb.prototype=new Ytb;_.Ad=function lvb(){return null};_.gC=function mvb(){return uy};_.Cd=function nvb(){return new yjb};_.cM={150:1};_=pvb.prototype=ovb.prototype=new mub;_.gC=function qvb(){return ty};_=svb.prototype=rvb.prototype=new Ytb;_.gC=function tvb(){return vy};_.cM={150:1,154:1};_=Jvb.prototype=Ivb.prototype=new Xtb;_.gC=function Kvb(){return By};_.Cd=function Lvb(){return new mlb};_.cM={148:1,150:1,156:1};_.a=null;_.b=null;_.c=0;_.d=null;_.e=null;_=Nvb.prototype=Mvb.prototype=new lub;_.gC=function Ovb(){return Ay};_.e=30;_=tEb.prototype;_.kb=function xEb(){iyb(this.b,new AEb(this.a))};_=AEb.prototype=yEb.prototype=new lyb;_.gC=function BEb(){return $z};_.cd=function CEb(){Z6(this,new Iob(45,f7(this.q.z),1,2000))};_.bb=function DEb(){var a,b,c,d,e,f,g,i,j,k,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C;frb(this.p.F,0,200,800);Ynb(this.s,this.p);c=new Kpb;for(i=0;i<=40;++i){U1(c.B,new jrb(-500,-75,i*25-500));U1(c.B,new jrb(500,-75,i*25-500));U1(c.B,new jrb(i*25-500,-75,-500));U1(c.B,new jrb(i*25-500,-75,500))}o=new wub;o.a=new Wob(16777215);o.t=0.20000000298023224;n=new sub(o);k=new mwb(c,n,(vwb(),twb));Ynb(this.s,k);C=new Omb(zEb());C.o=true;this.a=new c2;u=new zvb;u.j=C;u.u=true;U1(this.a,new vvb(u));v=new zvb;v.g=new Wob(14540253);v.d=(Zub(),Wub);U1(this.a,new vvb(v));z=new Nvb;z.a=new Wob(197379);z.g=new Wob(14540253);z.f=new Wob(39168);z.e=30;z.d=Wub;U1(this.a,new Jvb(z));U1(this.a,new Cvb(new Gvb));q=new hvb;q.g=new Wob(16755200);q.u=true;q.q=(Hub(),Aub);U1(this.a,new cvb(q));w=new zvb;w.g=new Wob(14540253);w.d=Yub;U1(this.a,new vvb(w));z.j=C;z.u=true;U1(this.a,new Jvb(z));y=new Gvb;y.a=Yub;U1(this.a,new Cvb(y));r=new hvb;r.g=new Wob(65450);r.w=true;U1(this.a,new cvb(r));U1(this.a,new kvb(new pvb));x=new zvb;x.g=new Wob(6710886);x.c=new Wob(16711680);x.a=new Wob(0);x.d=Yub;U1(this.a,new vvb(x));A=new Nvb;A.a=new Wob(0);A.c=new Wob(16711680);A.g=new Wob(0);A.f=new Wob(6710886);A.e=10;A.d=Yub;A.t=0.8999999761581421;A.u=true;U1(this.a,new Jvb(A));s=new hvb;r.j=C;r.u=true;U1(this.a,new cvb(s));g=new Qsb(70,32,16);e=new Qsb(70,32,16);f=new Qsb(70,32,16);for(i=0,j=f.n.b;i<j;++i){b=rp(Y1(f.n,i),133);b.g=0}Jpb(f,this.a);U1(this.a,new svb);this.b=new c2;for(i=0,j=this.a.b;i<j;++i){p=rp(Y1(this.a,i),150);d=p.gC()==vy?f:p.N==Wub?e:g;B=new Jwb(d,p);Vqb(B.F,i%4*200-400);grb(B.F,Math.floor(i/4)*200-200);Vqb(B.I,Math.random()*200-100);Wqb(B.I,Math.random()*200-100);grb(B.I,Math.random()*200-100);U1(this.b,B);Ynb(this.s,B)}t=new hvb;t.g=new Wob(16777215);this.c=new Jwb(new Qsb(4,8,8),new cvb(t));Ynb(this.s,this.c);Ynb(this.s,new Ntb(1118481));a=new Rtb(0.125);Vqb(a.F,Math.random()-0.5);Wqb(a.F,Math.random()-0.5);grb(a.F,Math.random()-0.5);a.F.wd();Ynb(this.s,a);this.d=new Vtb;Ynb(this.s,this.d)};_.ad=function EEb(){};_.cb=function FEb(a){var b,c,d,e,f;f=1.0E-4*a;Vqb(this.p.F,Math.cos(f)*1000);grb(this.p.F,Math.sin(f)*1000);mob(this.p,this.s.F);for(b=0,c=this.b.b;b<c;++b){e=rp(Y1(this.b,b),161);e.I.c+=0.009999999776482582;e.I.d+=0.004999999888241291;d=rp(Y1(this.a,b),150);b>9&&tp(d,156)?Rob(rp(d,156).b,0.5400000214576721,1,0.7*(0.5+0.5*Math.sin(35*f))):b>9&&tp(d,155)&&Rob(rp(d,155).b,0.03999999910593033,1,0.7*(0.5+0.5*Math.cos(35*f)))}Vqb(this.c.F,Math.sin(f*7)*300);Wqb(this.c.F,Math.cos(f*5)*400);grb(this.c.F,Math.cos(f*3)*300);Vqb(this.d.F,this.c.F.c);Wqb(this.d.F,this.c.F.d);grb(this.d.F,this.c.F.b);Y6(this)};_.a=null;_.b=null;_.c=null;_.d=null;var Hw=pY(d_b,W0b),Gw=pY(d_b,X0b),Ew=pY(d_b,Y0b),Fw=pY(d_b,Z0b),Xw=pY(d_b,$0b),Ww=pY(d_b,_0b),Uw=pY(d_b,a1b),Vw=pY(d_b,b1b),ty=pY(c1b,d1b),vy=pY(c1b,e1b),Ay=pY(c1b,f1b),$z=pY(UZb,g1b);NHb(Md)(10);