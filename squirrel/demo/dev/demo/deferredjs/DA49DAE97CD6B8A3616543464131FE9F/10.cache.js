function Ohb(){}
function Xhb(){}
function Uhb(){}
function _hb(){}
function aib(){}
function eib(){}
function dib(){}
function Cjb(){}
function Njb(){}
function Kjb(){}
function Sjb(){}
function Rjb(){}
function Wjb(){}
function Vjb(){}
function jsb(){}
function Atb(){}
function Ftb(){}
function Itb(){}
function Ztb(){}
function bub(){}
function xCb(){}
function $nb(a,b){a.r=b}
function zCb(){Dwb.call(this)}
function Jtb(){tsb.call(this,new Esb)}
function Phb(){Pgb.call(this,(Thb(),Shb))}
function Djb(){Pgb.call(this,(Jjb(),Ijb))}
function Btb(a){tsb.call(this,a);ssb(this,a.a)}
function Gtb(){Esb.call(this);this.a=(otb(),ntb)}
function Thb(){Thb=yFb;Shb=new Xhb}
function hib(){hib=yFb;Vhb=new aib}
function iib(){iib=yFb;Whb=new eib}
function Jjb(){Jjb=yFb;Ijb=new Njb}
function Zjb(){Zjb=yFb;Ljb=new Sjb}
function $jb(){$jb=yFb;Mjb=new Wjb}
function ksb(){_rb.call(this,16777215);this.b=1;this.a=0;new Apb(0,0,0)}
function $tb(a){zsb.call(this,a);this.a=a.a;this.b=a.c;this.d=a.f;this.c=a.e;this.j=null;this.g=a.b;ssb(this,a.d)}
function cub(){Gsb.call(this);this.a=new lnb(328965);this.f=new lnb(1118481);this.c=new lnb(0);this.b=(Hlb(),Glb);this.d=(otb(),ntb)}
function yCb(){var a,b,c,d,e,f,g,i;a=$doc.createElement(cKb);a.width=256;a.height=256;b=a.getContext(dKb);d=b.getImageData(0,0,256,256);i=0;for(c=0,e=0,f=d.data.length;c<f;c+=4,++e){g=e%64;i=g==0?i+1:i;d.data[c]=255;d.data[c+1]=255;d.data[c+2]=255;d.data[c+3]=ep(Math.floor(g^i))}b.putImageData(d,0,0);return a}
_=Phb.prototype=Ohb.prototype=new Kgb;_.gC=function Qhb(){return iw};_.Yc=function Rhb(){Mgb(this,'mNear',new akb((vkb(),hkb),new _W(1)));Mgb(this,'mFar',new akb(hkb,new _W(2000)));Mgb(this,HJb,new akb(hkb,new _W(1)))};var Shb;_=Xhb.prototype=Uhb.prototype=new Jb;_.gC=function Yhb(){return hw};_._c=function Zhb(){return hib(),Vhb};_.ad=function $hb(){return iib(),Whb};var Vhb=null,Whb=null;_=aib.prototype=_hb.prototype=new Jb;_.gC=function bib(){return fw};_.Jb=function cib(){return 'uniform float mNear;\r\nuniform float mFar;\r\nuniform float opacity;\r\n\r\nvoid main() {\r\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\r\n\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\r\n\tgl_FragColor = vec4( vec3( color ), opacity );\r\n}\r\n'};_.cM={44:1};_=eib.prototype=dib.prototype=new Jb;_.gC=function fib(){return gw};_.Jb=function gib(){return 'void main() {\r\n\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n}\r\n'};_.cM={44:1};_=Djb.prototype=Cjb.prototype=new Kgb;_.gC=function Ejb(){return yw};_.Yc=function Fjb(){Lgb(this,(Ekb(),zkb));Lgb(this,Akb);Lgb(this,Bkb);Lgb(this,Dkb);Mgb(this,IJb,new akb((vkb(),gkb),new lnb(16777215)));Mgb(this,JJb,new akb(gkb,new lnb(0)));Mgb(this,'specular',new akb(gkb,new lnb(1118481)));Mgb(this,'shininess',new akb(hkb,new _W(30)));Mgb(this,KJb,new akb(rkb,new Apb(1,1,1)))};_.Zc=function Gjb(a){var b,c;c=new V0(Ro(lA,{78:1,79:1,83:1,94:1},1,[JIb,LJb,MJb,NJb,KIb,'uniform vec3 ambientLightColor;\r\n\r\n#if MAX_DIR_LIGHTS > 0\r\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\r\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\r\n#endif\r\n\r\n#if MAX_POINT_LIGHTS > 0\r\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\r\n\r\n\t#ifdef PHONG_PER_PIXEL\r\n\t\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\r\n\t\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\r\n\t#else\r\n\t\tvarying vec4 vPointLight[ MAX_POINT_LIGHTS ];\r\n\t#endif\r\n#endif\r\n\r\n#if MAX_SPOT_LIGHTS > 0\r\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\r\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\r\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\r\n\tuniform float spotLightAngle[ MAX_SPOT_LIGHTS ];\r\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\r\n\r\n\t#ifdef PHONG_PER_PIXEL\r\n\t\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\r\n\t#else\r\n\t\tvarying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\r\n\t#endif\r\n\r\n\tvarying vec3 vWorldPosition;\r\n\r\n#endif\r\n\r\n#ifdef WRAP_AROUND\r\n\tuniform vec3 wrapRGB;\r\n#endif\r\n\r\nvarying vec3 vViewPosition;\r\nvarying vec3 vNormal;',LIb]));b=new V0(Ro(lA,{78:1,79:1,83:1,94:1},1,[OJb,MIb,'vec3 normal = normalize( vNormal );\r\nvec3 viewPosition = normalize( vViewPosition );\r\n\r\n#ifdef DOUBLE_SIDED\r\n\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\r\n#endif\r\n\r\n#if MAX_POINT_LIGHTS > 0\r\n\tvec3 pointDiffuse  = vec3( 0.0 );\r\n\tvec3 pointSpecular = vec3( 0.0 );\r\n\r\n\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\r\n\t\t#ifdef PHONG_PER_PIXEL\r\n\t\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\r\n\t\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\r\n\r\n\t\t\tfloat lDistance = 1.0;\r\n\t\t\tif ( pointLightDistance[ i ] > 0.0 )\r\n\t\t\t\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\r\n\r\n\t\t\tlVector = normalize( lVector );\r\n\t\t#else\r\n\t\t\tvec3 lVector = normalize( vPointLight[ i ].xyz );\r\n\t\t\tfloat lDistance = vPointLight[ i ].w;\r\n\t\t#endif\r\n\r\n\t\t// diffuse\r\n\r\n\t\tfloat dotProduct = dot( normal, lVector );\r\n\r\n\t\t#ifdef WRAP_AROUND\r\n\t\t\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\r\n\t\t\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\r\n\t\t\tvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\r\n\t\t#else\r\n\t\t\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\r\n\t\t#endif\r\n\r\n\t\tpointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\r\n\r\n\t\t// specular\r\n\r\n\t\tvec3 pointHalfVector = normalize( lVector + viewPosition );\r\n\t\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\r\n\t\tfloat pointSpecularWeight = max( pow( pointDotNormalHalf, shininess ), 0.0 );\r\n\r\n\t\t#ifdef PHYSICALLY_BASED_SHADING\r\n\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\t\t\tfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\r\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );\r\n\t\t\tpointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\r\n\t\t#else\r\n\t\t\tpointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;\r\n\t\t#endif\r\n\t}\r\n\r\n#endif\r\n\r\n#if MAX_SPOT_LIGHTS > 0\r\n\tvec3 spotDiffuse  = vec3( 0.0 );\r\n\tvec3 spotSpecular = vec3( 0.0 );\r\n\r\n\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\r\n\t\t#ifdef PHONG_PER_PIXEL\r\n\t\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\r\n\t\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\r\n\r\n\t\t\tfloat lDistance = 1.0;\r\n\t\t\tif ( spotLightDistance[ i ] > 0.0 )\r\n\t\t\t\tlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\r\n\r\n\t\t\tlVector = normalize( lVector );\r\n\t\t#else\r\n\t\t\tvec3 lVector = normalize( vSpotLight[ i ].xyz );\r\n\t\t\tfloat lDistance = vSpotLight[ i ].w;\r\n\t\t#endif\r\n\r\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\r\n\r\n\t\tif ( spotEffect > spotLightAngle[ i ] ) {\r\n\t\t\tspotEffect = pow( spotEffect, spotLightExponent[ i ] );\r\n\r\n\t\t\t// diffuse\r\n\r\n\t\t\tfloat dotProduct = dot( normal, lVector );\r\n\r\n\t\t\t#ifdef WRAP_AROUND\r\n\t\t\t\tfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\r\n\t\t\t\tfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\r\n\t\t\t\tvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\r\n\t\t\t#else\r\n\t\t\t\tfloat spotDiffuseWeight = max( dotProduct, 0.0 );\r\n\t\t\t#endif\r\n\r\n\t\t\tspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\r\n\r\n\t\t\t// specular\r\n\r\n\t\t\tvec3 spotHalfVector = normalize( lVector + viewPosition );\r\n\t\t\tfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\r\n\t\t\tfloat spotSpecularWeight = max( pow( spotDotNormalHalf, shininess ), 0.0 );\r\n\r\n\t\t\t#ifdef PHYSICALLY_BASED_SHADING\r\n\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\t\t\t\tfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\r\n\t\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );\r\n\t\t\t\tspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\r\n\t\t\t#else\r\n\t\t\t\tspotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;\r\n\t\t\t#endif\r\n\t\t}\r\n\t}\r\n\r\n#endif\r\n\r\n#if MAX_DIR_LIGHTS > 0\r\n\tvec3 dirDiffuse  = vec3( 0.0 );\r\n\tvec3 dirSpecular = vec3( 0.0 );\r\n\r\n\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\r\n\t\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\r\n\t\tvec3 dirVector = normalize( lDirection.xyz );\r\n\r\n\t\t// diffuse\r\n\r\n\t\tfloat dotProduct = dot( normal, dirVector );\r\n\r\n\t\t#ifdef WRAP_AROUND\r\n\t\t\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\r\n\t\t\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\r\n\t\t\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\r\n\t\t#else\r\n\t\t\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\r\n\t\t#endif\r\n\r\n\t\tdirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\r\n\r\n\t\t// specular\r\n\r\n\t\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\r\n\t\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\r\n\t\tfloat dirSpecularWeight = max( pow( dirDotNormalHalf, shininess ), 0.0 );\r\n\r\n\t\t#ifdef PHYSICALLY_BASED_SHADING\r\n\t\t/*\r\n\t\t\t// fresnel term from skin shader\r\n\t\t\tconst float F0 = 0.128;\r\n\t\t\tfloat base = 1.0 - dot( viewPosition, dirHalfVector );\r\n\t\t\tfloat exponential = pow( base, 5.0 );\r\n\t\t\tfloat fresnel = exponential + F0 * ( 1.0 - exponential );\r\n\t\t*/\r\n\r\n\t\t/*\r\n\t\t\t// fresnel term from fresnel shader\r\n\t\t\tconst float mFresnelBias = 0.08;\r\n\t\t\tconst float mFresnelScale = 0.3;\r\n\t\t\tconst float mFresnelPower = 5.0;\r\n\t\t\tfloat fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\r\n\t\t*/\r\n\r\n\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\t\t\tfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\r\n\t\t\t//dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\r\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\r\n\t\t\tdirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\r\n\t\t\r\n\t\t#else\r\n\t\t\tdirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;\r\n\t\t#endif\r\n\t}\r\n\r\n#endif\r\n\r\nvec3 totalDiffuse = vec3( 0.0 );\r\nvec3 totalSpecular = vec3( 0.0 );\r\n\r\n#if MAX_DIR_LIGHTS > 0\r\n\ttotalDiffuse += dirDiffuse;\r\n\ttotalSpecular += dirSpecular;\r\n#endif\r\n\r\n#if MAX_POINT_LIGHTS > 0\r\n\ttotalDiffuse += pointDiffuse;\r\n\ttotalSpecular += pointSpecular;\r\n#endif\r\n\r\n#if MAX_SPOT_LIGHTS > 0\r\n\ttotalDiffuse += spotDiffuse;\r\n\ttotalSpecular += spotSpecular;\r\n#endif\r\n\r\n#ifdef METAL\r\n\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\r\n#else\r\n\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\r\n#endif',PJb,NIb,QJb,OIb,RJb,PIb]));Ngb(this,Tgb(a,Ro(nA,{78:1,94:1},101,[c,b])))};_.$c=function Hjb(a){var b,c,d,e;e=new V0(Ro(lA,{78:1,79:1,83:1,94:1},1,[SJb,TJb,UJb,'#ifndef PHONG_PER_PIXEL\r\n\r\n\t#if MAX_POINT_LIGHTS > 0\r\n\t\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\r\n\t\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\r\n\r\n\t\tvarying vec4 vPointLight[ MAX_POINT_LIGHTS ];\r\n\t#endif\r\n\r\n\t#if MAX_SPOT_LIGHTS > 0\r\n\t\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\r\n\t\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\r\n\r\n\t\tvarying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\r\n\t#endif\r\n\r\n#endif\r\n\r\n#if MAX_SPOT_LIGHTS > 0\r\n\tvarying vec3 vWorldPosition;\r\n#endif',JIb,VJb,WJb,QIb]));b=new V0(Ro(lA,{78:1,79:1,83:1,94:1},1,[XJb,YJb,ZJb,RIb]));c=new V0(Ro(lA,{78:1,79:1,83:1,94:1},1,[$Jb]));d=new V0(Ro(lA,{78:1,79:1,83:1,94:1},1,['#ifndef PHONG_PER_PIXEL\r\n\r\n\t#if MAX_POINT_LIGHTS > 0\r\n\t\tfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\r\n\t\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\r\n\t\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\r\n\r\n\t\t\tfloat lDistance = 1.0;\r\n\t\t\tif ( pointLightDistance[ i ] > 0.0 )\r\n\t\t\t\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\r\n\t\t\t\r\n\t\t\tvPointLight[ i ] = vec4( lVector, lDistance );\r\n\t\t}\r\n\r\n\t#endif\r\n\r\n\t#if MAX_SPOT_LIGHTS > 0\r\n\t\tfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\r\n\t\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\r\n\t\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\r\n\r\n\t\t\tfloat lDistance = 1.0;\r\n\t\t\tif ( spotLightDistance[ i ] > 0.0 )\r\n\t\t\t\tlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\r\n\t\t\t\r\n\t\t\tvSpotLight[ i ] = vec4( lVector, lDistance );\r\n\r\n\t\t}\r\n\r\n\t#endif\r\n\r\n#endif\r\n\r\n#if MAX_SPOT_LIGHTS > 0\r\n\tvWorldPosition = mPosition.xyz;\r\n#endif',_Jb,aKb,bKb,SIb]));Ogb(this,Tgb(a,Ro(nA,{78:1,94:1},101,[e,b,c,d])))};var Ijb;_=Njb.prototype=Kjb.prototype=new Jb;_.gC=function Ojb(){return xw};_._c=function Pjb(){return Zjb(),Ljb};_.ad=function Qjb(){return $jb(),Mjb};var Ljb=null,Mjb=null;_=Sjb.prototype=Rjb.prototype=new Jb;_.gC=function Tjb(){return vw};_.Jb=function Ujb(){return 'uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\nuniform vec3 ambient;\r\nuniform vec3 emissive;\r\nuniform vec3 specular;\r\nuniform float shininess;\r\n\r\n//[*]\r\n\t\t\t\r\nvoid main() {\r\n\tgl_FragColor = vec4( vec3 ( 1.0 ), opacity );\r\n\t\t\t\t\r\n//[*]\r\n\t\t\t\t\r\n}\r\n'};_.cM={44:1};_=Wjb.prototype=Vjb.prototype=new Jb;_.gC=function Xjb(){return ww};_.Jb=function Yjb(){return 'varying vec3 vViewPosition;\r\nvarying vec3 vNormal;\r\n\r\n//[*]\r\n\t\t\t\r\nvoid main() {\r\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\r\n\t\t\t\t\r\n//[*]\r\n\t\t\t\r\n#ifndef USE_ENVMAP\r\n\tvec4 mPosition = objectMatrix * vec4( position, 1.0 );\r\n#endif\r\n\r\nvViewPosition = -mvPosition.xyz;\r\n\t\t\t\r\n//[*]\r\n\t\t\t\r\nvNormal = transformedNormal;\r\n\r\n//[*]\r\n\r\n}\r\n'};_.cM={44:1};_=ksb.prototype=jsb.prototype=new $rb;_.gC=function lsb(){return Jx};_.cM={145:1,146:1,157:1};_.a=0;_.b=0;_=Btb.prototype=Atb.prototype=new nsb;_.td=function Ctb(){return null};_.gC=function Dtb(){return Xx};_.vd=function Etb(){return new Phb};_.cM={149:1};_=Gtb.prototype=Ftb.prototype=new Dsb;_.gC=function Htb(){return Wx};_=Jtb.prototype=Itb.prototype=new nsb;_.gC=function Ktb(){return Yx};_.cM={149:1,153:1};_=$tb.prototype=Ztb.prototype=new msb;_.gC=function _tb(){return cy};_.vd=function aub(){return new Djb};_.cM={147:1,149:1,155:1};_.a=null;_.b=null;_.c=0;_.d=null;_.e=null;_=cub.prototype=bub.prototype=new Csb;_.gC=function dub(){return by};_.e=30;_=sCb.prototype;_.kb=function wCb(){zwb(this.b,new zCb(this.a))};_=zCb.prototype=xCb.prototype=new Cwb;_.gC=function ACb(){return Bz};_.Xc=function BCb(){o5(this,new Zmb(45,w5(this.q.z),1,2000))};_.bb=function CCb(){var a,b,c,d,e,f,g,i,j,k,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C;wpb(this.p.F,0,200,800);nmb(this.s,this.p);c=new _nb;for(i=0;i<=40;++i){j0(c.B,new Apb(-500,-75,i*25-500));j0(c.B,new Apb(500,-75,i*25-500));j0(c.B,new Apb(i*25-500,-75,-500));j0(c.B,new Apb(i*25-500,-75,500))}o=new Nsb;o.a=new lnb(16777215);o.t=0.20000000298023224;n=new Jsb(o);k=new Dub(c,n,(Mub(),Kub));nmb(this.s,k);C=new dlb(yCb());C.o=true;this.a=new t0;u=new Qtb;u.j=C;u.u=true;j0(this.a,new Mtb(u));v=new Qtb;v.g=new lnb(14540253);v.d=(otb(),ltb);j0(this.a,new Mtb(v));z=new cub;z.a=new lnb(197379);z.g=new lnb(14540253);z.f=new lnb(39168);z.e=30;z.d=ltb;j0(this.a,new $tb(z));j0(this.a,new Ttb(new Xtb));q=new ytb;q.g=new lnb(16755200);q.u=true;q.q=(Ysb(),Rsb);j0(this.a,new ttb(q));w=new Qtb;w.g=new lnb(14540253);w.d=ntb;j0(this.a,new Mtb(w));z.j=C;z.u=true;j0(this.a,new $tb(z));y=new Xtb;y.a=ntb;j0(this.a,new Ttb(y));r=new ytb;r.g=new lnb(65450);r.w=true;j0(this.a,new ttb(r));j0(this.a,new Btb(new Gtb));x=new Qtb;x.g=new lnb(6710886);x.c=new lnb(16711680);x.a=new lnb(0);x.d=ntb;j0(this.a,new Mtb(x));A=new cub;A.a=new lnb(0);A.c=new lnb(16711680);A.g=new lnb(0);A.f=new lnb(6710886);A.e=10;A.d=ntb;A.t=0.8999999761581421;A.u=true;j0(this.a,new $tb(A));s=new ytb;r.j=C;r.u=true;j0(this.a,new ttb(s));g=new frb(70,32,16);e=new frb(70,32,16);f=new frb(70,32,16);for(i=0,j=f.n.b;i<j;++i){b=$o(n0(f.n,i),132);b.g=0}$nb(f,this.a);j0(this.a,new Jtb);this.b=new t0;for(i=0,j=this.a.b;i<j;++i){p=$o(n0(this.a,i),149);d=p.gC()==Yx?f:p.N==ltb?e:g;B=new $ub(d,p);kpb(B.F,i%4*200-400);xpb(B.F,Math.floor(i/4)*200-200);kpb(B.I,Math.random()*200-100);lpb(B.I,Math.random()*200-100);xpb(B.I,Math.random()*200-100);j0(this.b,B);nmb(this.s,B)}t=new ytb;t.g=new lnb(16777215);this.c=new $ub(new frb(4,8,8),new ttb(t));nmb(this.s,this.c);nmb(this.s,new csb(1118481));a=new gsb(0.125);kpb(a.F,Math.random()-0.5);lpb(a.F,Math.random()-0.5);xpb(a.F,Math.random()-0.5);a.F.pd();nmb(this.s,a);this.d=new ksb;nmb(this.s,this.d)};_.Vc=function DCb(){};_.cb=function ECb(a){var b,c,d,e,f;f=1.0E-4*a;kpb(this.p.F,Math.cos(f)*1000);xpb(this.p.F,Math.sin(f)*1000);Dmb(this.p,this.s.F);for(b=0,c=this.b.b;b<c;++b){e=$o(n0(this.b,b),160);e.I.c+=0.009999999776482582;e.I.d+=0.004999999888241291;d=$o(n0(this.a,b),149);b>9&&ap(d,155)?gnb($o(d,155).b,0.5400000214576721,1,0.7*(0.5+0.5*Math.sin(35*f))):b>9&&ap(d,154)&&gnb($o(d,154).b,0.03999999910593033,1,0.7*(0.5+0.5*Math.cos(35*f)))}kpb(this.c.F,Math.sin(f*7)*300);lpb(this.c.F,Math.cos(f*5)*400);xpb(this.c.F,Math.cos(f*3)*300);kpb(this.d.F,this.c.F.c);lpb(this.d.F,this.c.F.d);xpb(this.d.F,this.c.F.b);n5(this)};_.a=null;_.b=null;_.c=null;_.d=null;var iw=GW(nJb,'ShaderDepth'),hw=GW(nJb,'ShaderDepth_Resources_default_InlineClientBundleGenerator'),fw=GW(nJb,'ShaderDepth_Resources_default_InlineClientBundleGenerator$1'),gw=GW(nJb,'ShaderDepth_Resources_default_InlineClientBundleGenerator$2'),yw=GW(nJb,'ShaderPhong'),xw=GW(nJb,'ShaderPhong_Resources_default_InlineClientBundleGenerator'),vw=GW(nJb,'ShaderPhong_Resources_default_InlineClientBundleGenerator$1'),ww=GW(nJb,'ShaderPhong_Resources_default_InlineClientBundleGenerator$2'),Wx=GW(eKb,'MeshDepthMaterial$MeshDepthMaterialOptions'),Yx=GW(eKb,'MeshFaceMaterial'),by=GW(eKb,'MeshPhongMaterial$MeshPhongMaterialOptions'),Bz=GW(IIb,'MaterialsCanvas2D$DemoScene');AFb(Md)(10);