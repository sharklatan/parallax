<pre>
/*
 * Load texture
 */
public interface Resources extends ClientBundle
{
   Resources INSTANCE = GWT.create(Resources.class);
   
   @Source("../../resources/textures/cube/skybox/px.jpg")
   ImageResource px();
   
   @Source("../../resources/textures/cube/skybox/nx.jpg")
   ImageResource nx();
   
   @Source("../../resources/textures/cube/skybox/py.jpg")
   ImageResource py();
   
   @Source("../../resources/textures/cube/skybox/ny.jpg")
   ImageResource ny();
   
   @Source("../../resources/textures/cube/skybox/pz.jpg")
   ImageResource pz();
         
   @Source("../../resources/textures/cube/skybox/nz.jpg")
   ImageResource nz();
}



/*
 * Prepare Rendering Scene
 */
class DemoScene extends DemoRenderingScene 
{
   public int mouseX = 0;
   public int mouseY = 0;
   
   private List&lt;Mesh&gt; speres;
   
   private Scene sceneCube;
   private PerspectiveCamera cameraCube;
   
   @Override
   protected void loadCamera()
   {
      setCamera(
            new PerspectiveCamera(
                  60, // fov
                  getRenderer().getCanvas().getAspectRation(), // aspect 
                  1, // near
                  100000 // far 
            )); 
   }

   @Override
   protected void onStart()
   {
      getCamera().getPosition().setZ(3200);
      getScene().addChild(getCamera());
      
      this.sceneCube = new Scene();
      this.cameraCube = new PerspectiveCamera( 60, getRenderer().getCanvas().getAspectRation(), 1, 100000 );

      sceneCube.addChild( cameraCube );

      Sphere geometry = new Sphere( 100, 32, 16 );


      Resources r = Resources.INSTANCE;
      CubeTexture textureCube = ImageUtils.loadTextureCube( Arrays.asList(r.px(), r.nx(), r.py(), r.ny(), r.pz(), r.nz()), Texture.MAPPING_MODE.CUBE_REFRACTION, null );
      
      MeshBasicMaterial.MeshBasicMaterialOptions mbOpt = new MeshBasicMaterial.MeshBasicMaterialOptions();
      mbOpt.color = new Color3f(0xffffff);
      mbOpt.envMap = textureCube;
      mbOpt.refractionRatio = 0.95f;
      
      MeshBasicMaterial material = new MeshBasicMaterial( mbOpt );

      this.speres = new ArrayList&lt;Mesh&gt;();
      
      for ( int i = 0; i &lt; 500; i ++ ) 
      {
         Mesh mesh = new Mesh( geometry, material );

         mesh.getPosition().setX( (float) (Math.random() * 10000.0 - 5000.0) );
         mesh.getPosition().setY( (float) (Math.random() * 10000.0 - 5000.0) );
         mesh.getPosition().setZ( (float) (Math.random() * 10000.0 - 5000.0) );

         float scale = (float) (Math.random() * 3.0 + 1.0);
         mesh.getScale().set(scale, scale, scale);

         getScene().addChild( mesh );

         this.speres.add( mesh );
      }

      // Skybox

      ShaderCubeMap shader = new ShaderCubeMap();
      shader.getUniforms().get("tCube").texture = textureCube; 

      ShaderMaterial.ShaderMaterialOptions sOpt = new ShaderMaterial.ShaderMaterialOptions();
      sOpt.fragmentShader = shader.getFragmentSource();
      sOpt.vertexShader = shader.getVertexSource();
      sOpt.uniforms = shader.getUniforms();
      sOpt.depthWrite = false;
      
      ShaderMaterial sMaterial = new ShaderMaterial( sOpt );
      Mesh mesh = new Mesh( new Cube( 100, 100, 100 ), sMaterial );
      mesh.setFlipSided(true);
      sceneCube.addChild( mesh );
      
      getRenderer().autoClear = false;
   }
   
   @Override
   protected void onStop()
   {         
   }
   
   @Override
   protected void onUpdate(double duration)
   {
      double timer = 0.0001 * duration;

      for ( int i = 0, il = this.speres.size(); i &lt; il; i ++ ) 
      {
         this.speres.get(i).getPosition().setX( (float) (5000.0 * Math.cos( timer + i )) );
         this.speres.get(i).getPosition().setY( (float) (5000.0 * Math.sin( timer + i * 1.1 )) );
      }

      getCamera().getPosition().addX((float) (( mouseX - getCamera().getPosition().getX() ) * 0.05) );
      getCamera().getPosition().addY((float) (( - mouseY - getCamera().getPosition().getY() ) * 0.05) );

      getCamera().lookAt( getScene().getPosition() );
      this.cameraCube.getRotation().copy( getCamera().getRotation() );

      getRenderer().render( sceneCube, cameraCube );
      
      super.onUpdate(duration);
   }
}


</pre>