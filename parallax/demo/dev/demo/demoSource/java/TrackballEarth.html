<pre>
/*
 * Load textures
 */
public interface Resources extends ClientBundle
{
   Resources INSTANCE = GWT.create(Resources.class);

   @Source("../../resources/textures/planets/earth_atmos_2048.jpg")
   ImageResource earthAtmos();
   
   @Source("../../resources/textures/planets/earth_clouds_1024.png")
   ImageResource earthClouds();
   
   @Source("../../resources/textures/planets/earth_normal_2048.jpg")
   ImageResource earthNormal();
   
   @Source("../../resources/textures/planets/earth_specular_2048.jpg")
   ImageResource earthSpecular();
   
   @Source("../../resources/textures/planets/moon_1024.jpg")
   ImageResource moon();
}



/*
 * Prepare Rendering Scene
 */
class DemoScene extends DemoRenderingScene 
{
   static final int radius = 6371;
   static final float tilt = 0.41f;
   static final float rotationSpeed = 0.1f;

   static final float cloudsScale = 1.005f;
   static final float moonScale = 0.23f;
   
   Mesh meshPlanet;
   Mesh meshClouds;
   Mesh meshMoon;
   
   private TrackballControl control;
   private double oldTime;
   
   @Override
   protected void loadCamera()
   {
      setCamera(
            new PerspectiveCamera(
                  25, // fov
                  getRenderer().getCanvas().getAspectRation(), // aspect 
                  50, // near
                  1e7f // far 
            )); 
   }

   @Override
   protected void onStart()
   {
      getCamera().getPosition().setZ(radius * 7);
      getScene().addChild(getCamera());

      this.control = new TrackballControl( getCamera(), getRenderer().getCanvas() );
      this.control.setPanSpeed(0.2f);
      this.control.setDynamicDampingFactor(0.3f);
      this.control.setMinDistance(radius * 1.1f);
      this.control.setMaxDistance(radius * 100f);

      DirectionalLight dirLight = new DirectionalLight( 0xFFFFFF );
      dirLight.getPosition().set( -1f, 0f, 1f ).normalize();
      getScene().addChild( dirLight );

      Texture planetTexture   = ImageUtils.loadTexture( Resources.INSTANCE.earthAtmos(), null, null );
      Texture cloudsTexture   = ImageUtils.loadTexture( Resources.INSTANCE.earthClouds(), null, null );
      Texture normalTexture   = ImageUtils.loadTexture( Resources.INSTANCE.earthNormal(), null, null );
      Texture specularTexture = ImageUtils.loadTexture( Resources.INSTANCE.earthSpecular(), null, null );
      Texture moonTexture     = ImageUtils.loadTexture( Resources.INSTANCE.moon(), null, null );

      ShaderNormalMap shader = new ShaderNormalMap();
      Map&lt;String, Uniform&gt; uniforms = UniformsUtils.clone( shader.getUniforms() );

      uniforms.get("tNormal").texture = normalTexture;
      uniforms.get("uNormalScale").value = 0.85f;

      uniforms.get("tDiffuse").texture = planetTexture;
      uniforms.get("tSpecular").texture = specularTexture;

      uniforms.get("enableAO").value = 0;
      uniforms.get("enableDiffuse").value = 1;
      uniforms.get("enableSpecular").value = 1;

      ((Color3f)uniforms.get("uDiffuseColor").value).setHex( 0xffffff );
      ((Color3f)uniforms.get("uSpecularColor").value).setHex( 0x666666 );
      ((Color3f)uniforms.get("uAmbientColor").value).setHex( 0x000000 );

      uniforms.get("uShininess").value = 20f;

      ((Color3f)uniforms.get("uDiffuseColor").value).convertGammaToLinear();
      ((Color3f)uniforms.get("uSpecularColor").value).convertGammaToLinear();
      ((Color3f)uniforms.get("uAmbientColor").value).convertGammaToLinear();

      ShaderMaterial.ShaderMaterialOptions sOpt = new ShaderMaterial.ShaderMaterialOptions(); 
      sOpt.fragmentShader = shader.getFragmentSource();
      sOpt.vertexShader = shader.getVertexSource();
      sOpt.uniforms = uniforms;
      sOpt.lights = true;
      ShaderMaterial materialNormalMap = new ShaderMaterial(sOpt);

      // planet

      Sphere geometry = new Sphere( radius, 100, 50 );
      geometry.computeTangents();

      this.meshPlanet = new Mesh( geometry, materialNormalMap );
      meshPlanet.getRotation().setY( 0 );
      meshPlanet.getRotation().setZ( tilt );
      getScene().addChild( meshPlanet );


      // clouds
      MeshLambertMaterial.MeshLambertMaterialOptions mlOpt = new MeshLambertMaterial.MeshLambertMaterialOptions();
      mlOpt.color = new Color3f(0xffffff);
      mlOpt.map = cloudsTexture;
      mlOpt.transparent = true;
      MeshLambertMaterial materialClouds = new MeshLambertMaterial( mlOpt );

      this.meshClouds = new Mesh( geometry, materialClouds );
      meshClouds.getScale().set( cloudsScale, cloudsScale, cloudsScale );
      meshClouds.getRotation().setZ( tilt );
      getScene().addChild( meshClouds );


      // moon
      MeshPhongMaterial.MeshPhongMaterialOptions mpOpt = new MeshPhongMaterial.MeshPhongMaterialOptions();
      mpOpt.color = new Color3f(0xffffff);
      mpOpt.map = moonTexture;
      MeshPhongMaterial materialMoon = new MeshPhongMaterial( mpOpt );

      this.meshMoon = new Mesh( geometry, materialMoon );
      meshMoon.getPosition().set( radius * 5.0f, 0, 0 );
      meshMoon.getScale().set( moonScale, moonScale, moonScale );
      getScene().addChild( meshMoon );


      // stars

      Geometry starsGeometry = new Geometry();

      for ( int i = 0; i &lt; 1500; i ++ ) 
      {

         Vector3f vertex = new Vector3f();
         vertex.setX( (float) (Math.random() * 2.0 - 1.0) );
         vertex.setY( (float) (Math.random() * 2.0 - 1.0) );
         vertex.setZ( (float) (Math.random() * 2.0 - 1.0) );
         vertex.multiply( radius );

         starsGeometry.getVertices().add( vertex );

      }

      ParticleBasicMaterial.ParticleBasicMaterialOptions pbOpt = new ParticleBasicMaterial.ParticleBasicMaterialOptions();
      pbOpt.color = new Color3f(0x555555);
      pbOpt.size = 2;
      pbOpt.sizeAttenuation = false;
      
      List&lt;ParticleBasicMaterial&gt; starsMaterials = new ArrayList&lt;ParticleBasicMaterial&gt;();
      starsMaterials.add(new ParticleBasicMaterial( pbOpt ));
      
      pbOpt.size = 1;
      starsMaterials.add(new ParticleBasicMaterial( pbOpt ));
      
      pbOpt.color = new Color3f(0x333333);
      pbOpt.size = 2;
      starsMaterials.add(new ParticleBasicMaterial( pbOpt ));
      
      pbOpt.color = new Color3f(0x3a3a3a);
      pbOpt.size = 1;
      starsMaterials.add(new ParticleBasicMaterial( pbOpt ));
      
      pbOpt.color = new Color3f(0x1a1a1a);
      pbOpt.size = 2;
      starsMaterials.add(new ParticleBasicMaterial( pbOpt ));
      
      pbOpt.color = new Color3f(0x1a1a1a);
      pbOpt.size = 1;
      starsMaterials.add(new ParticleBasicMaterial( pbOpt ));            

      for ( int i = 10; i &lt; 30; i ++ ) 
      {
         ParticleSystem stars = new ParticleSystem( starsGeometry, starsMaterials.get( i % 6 ) );

         stars.getRotation().setX( (float) (Math.random() * 6.0) );
         stars.getRotation().setY( (float) (Math.random() * 6.0) );
         stars.getRotation().setZ( (float) (Math.random() * 6.0) );

         float s = i * 10.0f;
         stars.getScale().set( s, s, s );

         stars.setMatrixAutoUpdate(false);
         stars.updateMatrix();

         getScene().addChild( stars );
      }
      
      getRenderer().setSortObjects(false);
      getRenderer().setAutoClear(false);

//         renderer.gammaInput = true;
//         renderer.gammaOutput = true;
      
      this.oldTime = Duration.currentTimeMillis();
   }
   
   @Override
   protected void onStop()
   {         
   }
   
   @Override
   protected void onUpdate(double duration)
   {
      float delta = (float) ((Duration.currentTimeMillis() - this.oldTime) * 0.001);

      meshPlanet.getRotation().addY( rotationSpeed * delta );
      meshClouds.getRotation().addY( 1.25f * rotationSpeed * delta );

      float angle = delta * rotationSpeed;

      meshMoon.setPosition( new Vector3f(
         (float)(Math.cos( angle ) * meshMoon.getPosition().getX() - Math.sin( angle ) * meshMoon.getPosition().getZ()),
         0,
         (float)(Math.sin( angle ) * meshMoon.getPosition().getX() + Math.cos( angle ) * meshMoon.getPosition().getZ())
      ));
      meshMoon.getRotation().addY( - angle );

      this.control.update();

      getRenderer().clear(false, false, false);
      
      this.oldTime = Duration.currentTimeMillis();
      super.onUpdate(duration);
   }
}


</pre>