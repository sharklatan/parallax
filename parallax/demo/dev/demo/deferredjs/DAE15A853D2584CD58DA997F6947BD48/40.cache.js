function zKb(){}
function DKb(){}
function GKb(){}
function huc(){}
function luc(){}
function ouc(){}
function Auc(){}
function Euc(){}
function Huc(){}
function Tuc(){}
function Xuc(){}
function $uc(){}
function N8b(a,b){a.d=b}
function vKb(){vKb=GKc;uKb=new zKb}
function IKb(){IKb=GKc;xKb=new DKb}
function JKb(){JKb=GKc;yKb=new GKb}
function Juc(){Juc=GKc;yuc=new Euc}
function duc(){duc=GKc;cuc=new huc}
function quc(){quc=GKc;fuc=new luc}
function ruc(){ruc=GKc;guc=new ouc}
function wuc(){wuc=GKc;vuc=new Auc}
function Kuc(){Kuc=GKc;zuc=new Huc}
function Puc(){Puc=GKc;Ouc=new Tuc}
function avc(){avc=GKc;Ruc=new Xuc}
function bvc(){bvc=GKc;Suc=new $uc}
function Xrc(a,b){this.b=a;this.c=b}
function ZGb(a,b){KHb(a,b);YGb(a,false)}
function qKb(){aJb.call(this,(vKb(),uKb))}
function auc(){aJb.call(this,(duc(),cuc))}
function tuc(){aJb.call(this,(wuc(),vuc))}
function Muc(){aJb.call(this,(Puc(),Ouc))}
function w0b(){$Zb.call(this);this.b=false;this.c=1}
function Trc(){hac.call(this);this.u=new D6b(0,1000,-1000);this.s=new C6b}
function u6b(a,b){var c;c=new M4b;K4b(c,b.q,z4b(c,b.Y));return m6b(a,c)}
var VTc='bgColor',XTc='fAspect',UTc='fGodRayIntensity',YTc='fStepSize',LTc='mFar',KTc='mNear',$Tc='tColors',_Tc='tGodRays',ZTc='tInput',WTc='vSunPositionScreenSpace',aUc='varying vec2 vUv;\n\nvoid main() {\n\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}';JU(749,731,eMc,qKb);_.Sd=function rKb(){QIb(this,KTc,new qNb((JNb(),vNb),new mkb(1)));QIb(this,LTc,new qNb(vNb,new mkb(2000)));QIb(this,pSc,new qNb(vNb,new mkb(1)))};_.Td=function sKb(a){var b,c;c=new zrb(Mu(GS,MKc,1,[MTc]));b=new zrb(Mu(GS,MKc,1,[NTc]));ZIb(this,fJb(a,Mu(JS,MKc,173,[c,b])))};_.Ud=function tKb(a){var b,c;c=new zrb(Mu(GS,MKc,1,[OTc,PTc]));b=new zrb(Mu(GS,MKc,1,[QTc,RTc,STc]));$Ib(this,fJb(a,Mu(JS,MKc,173,[c,b])))};var uKb;JU(750,1,{},zKb);_.Vd=function AKb(){return IKb(),xKb};_.Wd=function BKb(){return JKb(),yKb};var xKb,yKb;JU(751,1,{},DKb);_.uc=function EKb(){return 'uniform float mNear;\r\nuniform float mFar;\r\nuniform float opacity;\r\n\r\n[*]\r\n\r\nvoid main() {\r\n\r\n[*]\r\n\r\n\t#ifdef USE_LOGDEPTHBUF_EXT\r\n\r\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\r\n\r\n\t#else\r\n\r\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\r\n\r\n\t#endif\r\n\r\n\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\r\n\tgl_FragColor = vec4( vec3( color ), opacity );\r\n\r\n}'};JU(752,1,{},GKb);_.uc=function HKb(){return TTc};JU(816,813,{78:1,186:1,235:1,236:1,249:1});_.ee=function DQb(){return this.c};_.fe=function EQb(){return this.e};JU(817,813,{78:1,186:1,235:1,237:1,249:1});_.ee=function RQb(){return this.c};_.fe=function SQb(){return this.i};JU(921,914,{279:1,282:1},w0b);_.We=function x0b(){var a;return a=new w0b,IZb(this,a),a.b=this.b,a.c=this.c,a};_.Xe=function y0b(){return new qKb};_.Te=function z0b(){return this.c};_.Ue=function A0b(){return this.b};_.Ye=function B0b(a,b){var c;NZb(this,b);c=MZb(this).j;if(Zu(a,235)){oNb(Wu(c.b[KTc],225),new mkb(Wu(a,235).fe()));oNb(Wu(c.b[LTc],225),new mkb(Wu(a,235).ee()))}oNb(Wu(c.b[pSc],225),new mkb(this.$))};_.b=false;_.c=0;JU(1230,1,rMc);_.Db=function Rrc(){J9b(this.c,new Trc(this.b))};JU(1231,973,{336:1},Trc);_.ob=function Urc(){var a,b,c,d;this.b=new PQb(70,dHb(this.H.n),1,3000);z6b(this.b.ab,200);this.c=new w0b;c=new T_b;N_b(c,new I3b(0));R_b(c,(B_b(),y_b));new sxc('./static/models/obj/tree/tree.js',new Xrc(this,c));a=new mXb(1,20,10);this.t=new _7b(a,c);w6b(this.t.fb,20);MPb(this.I,this.t);NHb(this.H.n,false);xHb(this.H.n,false);AHb(this.H.n,1297,1);this.k=new O8b;this.j=new AQb(this.H.n.$,this.H.n.Z,-10000,10000);z6b(this.j.ab,100);MPb(this.k,this.j);this.o=new MOb(this.H.n.$,this.H.n.Z);cOb(this.o,(QEb(),KEb));aOb(this.o,(FEb(),DEb));ZNb(this.o,(_Cb(),$Cb));this.p=new MOb(this.H.n.$,this.H.n.Z);cOb(this.p,KEb);aOb(this.p,DEb);ZNb(this.p,$Cb);d=~~(this.H.n.$/4);b=~~(this.H.n.Z/4);this.q=new MOb(d,b);cOb(this.q,KEb);aOb(this.q,DEb);ZNb(this.q,$Cb);this.r=new MOb(d,b);cOb(this.r,KEb);aOb(this.r,DEb);ZNb(this.r,$Cb);this.f=new U2b(new tuc);this.d=new U2b(new auc);oNb(Wu(pSb(MZb(this.d).j,UTc),225),new mkb(0.75));this.e=new U2b(new Muc);F3b(Wu(Wu(pSb(MZb(this.e).j,VTc),225).e,293),1297);F3b(Wu(Wu(pSb(MZb(this.e).j,cTc),225).e,293),16772608);this.n=new _7b(new bXb(this.H.n.$,this.H.n.Z),this.f);z6b(this.n.ab,-9900);MPb(this.k,this.n)};_.pb=function Vrc(a){var b,c,d,e,f,g;f=a/4000;M5b(this.t.ab,200*mlb(f));z6b(this.t.ab,200*vlb(f)-100);H5b(this.b.ab,(this.g-this.b.ab.d)*0.036);I5b(this.b.ab,(-this.i-this.b.ab.e)*0.036);jQb(this.b,this.I.ab);u6b(this.s.sf(this.u),this.b);M5b(this.s,(this.s.d+1)/2);N5b(this.s,(this.s.e+1)/2);L5b(Wu(Wu(pSb(MZb(this.f).j,WTc),225).e,297),this.s.d,this.s.e);L5b(Wu(Wu(pSb(MZb(this.e).j,WTc),225).e,297),this.s.d,this.s.e);ZGb(this.H.n,this.o);g=this.H.n.$;b=this.H.n.Z;d=0.74*b;e=0.74*b;M5b(this.s,this.s.d*g);N5b(this.s,this.s.e*b);LHb(this.H.n,cv(this.s.d-e/2),cv(this.s.e-d/2),cv(e),cv(d));cHb(this.H.n,true);oNb(Wu(pSb(MZb(this.e).j,XTc),225),new mkb(g/b));N8b(this.k,this.e);pHb(this.H.n,this.k,this.j,this.o,false);cHb(this.H.n,false);N8b(this.I,null);pHb(this.H.n,this.I,this.b,this.o,false);N8b(this.I,this.c);pHb(this.H.n,this.I,this.b,this.p,true);c=slb(6,-1);oNb(Wu(pSb(MZb(this.f).j,YTc),225),new mkb(c));oNb(Wu(pSb(MZb(this.f).j,ZTc),225),this.p);N8b(this.k,this.f);pHb(this.H.n,this.k,this.j,this.r,false);c=slb(6,-2);oNb(Wu(pSb(MZb(this.f).j,YTc),225),new mkb(c));oNb(Wu(pSb(MZb(this.f).j,ZTc),225),this.r);pHb(this.H.n,this.k,this.j,this.q,false);c=slb(6,-3);oNb(Wu(pSb(MZb(this.f).j,YTc),225),new mkb(c));oNb(Wu(pSb(MZb(this.f).j,ZTc),225),this.q);pHb(this.H.n,this.k,this.j,this.r,false);oNb(Wu(pSb(MZb(this.d).j,$Tc),225),this.o);oNb(Wu(pSb(MZb(this.d).j,_Tc),225),this.r);N8b(this.k,this.d);pHb(this.H.n,this.k,this.j,null,false);N8b(this.k,null)};_.g=0;_.i=0;JU(1232,1,{},Xrc);_.Hf=function Yrc(a,b){var c;c=new _7b(b,this.c);x6b(c.ab,0,-150,-150);w6b(c.fb,400);c.X=false;u4b(c.W,c.ab,c.bb,c.fb);c.Z=true;MPb(this.b.I,c)};JU(1268,731,eMc,auc);_.Sd=function buc(){QIb(this,$Tc,new pNb((JNb(),BNb)));QIb(this,_Tc,new pNb(BNb));QIb(this,UTc,new qNb(vNb,new mkb(0.69)));QIb(this,WTc,new qNb(DNb,new P5b(0.5,0.5)))};var cuc;JU(1269,1,{},huc);_.Vd=function iuc(){return quc(),fuc};_.Wd=function juc(){return ruc(),guc};var fuc,guc;JU(1270,1,{},luc);_.uc=function muc(){return 'varying vec2 vUv;\n\nuniform sampler2D tColors;\nuniform sampler2D tGodRays;\n\nuniform vec2 vSunPositionScreenSpace;\nuniform float fGodRayIntensity;\n\nvoid main() {\n\n\t// Since THREE.MeshDepthMaterial renders foreground objects white and background\n\t// objects black, the god-rays will be white streaks. Therefore value is inverted\n\t// before being combined with tColors\n\n\tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );\n\tgl_FragColor.a = 1.0;\n\n}\n'};JU(1271,1,{},ouc);_.uc=function puc(){return aUc};JU(1274,731,eMc,tuc);_.Sd=function uuc(){QIb(this,ZTc,new pNb((JNb(),BNb)));QIb(this,YTc,new qNb(vNb,new mkb(1)));QIb(this,WTc,new qNb(DNb,new P5b(0.5,0.5)))};var vuc;JU(1275,1,{},Auc);_.Vd=function Buc(){return Juc(),yuc};_.Wd=function Cuc(){return Kuc(),zuc};var yuc,zuc;JU(1276,1,{},Euc);_.uc=function Fuc(){return "#define TAPS_PER_PASS 6.0\n\nvarying vec2 vUv;\n\nuniform sampler2D tInput;\n\nuniform vec2 vSunPositionScreenSpace;\nuniform float fStepSize; // filter step size\n\nvoid main() {\n\n\t// delta from current pixel to \"sun\" position\n\n\tvec2 delta = vSunPositionScreenSpace - vUv;\n\tfloat dist = length( delta );\n\n\t// Step vector (uv space)\n\n\tvec2 stepv = fStepSize * delta / dist;\n\n\t// Number of iterations between pixel and sun\n\n\tfloat iters = dist/fStepSize;\n\n\tvec2 uv = vUv.xy;\n\tfloat col = 0.0;\n\n\t// This breaks ANGLE in Chrome 22\n\t//\t- see http://code.google.com/p/chromium/issues/detail?id=153105\n\n/*\n\t// Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),\n\t// so i've just left the loop\n\n\tfor ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\n\n\t\t\t\t\t// Accumulate samples, making sure we dont walk past the light source.\n\n\t\t\t\t\t// The check for uv.y < 1 would not be necessary with \"border\" UV wrap\n\t\t\t\t\t// mode, with a black border colour. I don't think this is currently\n\t\t\t\t\t// exposed by three.js. As a result there might be artifacts when the\n\t\t\t\t\t// sun is to the left, right or bottom of screen as these cases are\n\t\t\t\t\t// not specifically handled.\n\n\t\tcol += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );\n\t\tuv += stepv;\n\n\t}\n*/\n\n\t// Unrolling loop manually makes it work in ANGLE\n\n\tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\n\tuv += stepv;\n\n\tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\n\tuv += stepv;\n\n\tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\n\tuv += stepv;\n\n\tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\n\tuv += stepv;\n\n\tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\n\tuv += stepv;\n\n\tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\n\tuv += stepv;\n\n\t// Should technically be dividing by 'iters', but 'TAPS_PER_PASS' smooths out\n\t// objectionable artifacts, in particular near the sun position. The side\n\t// effect is that the result is darker than it should be around the sun, as\n\t// TAPS_PER_PASS is greater than the number of samples actually accumulated.\n\t// When the result is inverted (in the shader 'godrays_combine', this produces\n\t// a slight bright spot at the position of the sun, even when it is occluded.\n\n\tgl_FragColor = vec4( col/TAPS_PER_PASS );\n\tgl_FragColor.a = 1.0;\n\n}\n"};JU(1277,1,{},Huc);_.uc=function Iuc(){return aUc};JU(1280,731,eMc,Muc);_.Sd=function Nuc(){QIb(this,WTc,new qNb((JNb(),DNb),new P5b(0.5,0.5)));QIb(this,XTc,new qNb(vNb,new mkb(1)));QIb(this,cTc,new qNb(uNb,new I3b(16772608)));QIb(this,VTc,new qNb(uNb,new I3b(0)))};var Ouc;JU(1281,1,{},Tuc);_.Vd=function Uuc(){return avc(),Ruc};_.Wd=function Vuc(){return bvc(),Suc};var Ruc,Suc;JU(1282,1,{},Xuc);_.uc=function Yuc(){return 'varying vec2 vUv;\n\nuniform vec2 vSunPositionScreenSpace;\nuniform float fAspect;\n\nuniform vec3 sunColor;\nuniform vec3 bgColor;\n\nvoid main() {\n\n\tvec2 diff = vUv - vSunPositionScreenSpace;\n\n\t// Correct for aspect ratio\n\n\tdiff.x *= fAspect;\n\n\tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );\n\tprop = 0.35 * pow( 1.0 - prop, 3.0 );\n\n\tgl_FragColor.xyz = mix( sunColor, bgColor, 1.0 - prop );\n\tgl_FragColor.w = 1.0;\n\n}\n'};JU(1283,1,{},$uc);_.uc=function _uc(){return aUc};var LO=akb(wRc,'PostprocessingGodrays$DemoScene',1231),KO=akb(wRc,'PostprocessingGodrays$DemoScene$1',1232),uJ=akb(bUc,'MeshDepthMaterial',921),nP=akb(mRc,'GodRaysGenerateShader',1274),jP=akb(mRc,'GodRaysCombineShader',1268),rP=akb(mRc,'GodraysFakeSunShader',1280),GG=akb(BSc,'DepthShader',749),mP=akb(mRc,'GodRaysGenerateShader_Resources_default_InlineClientBundleGenerator',1275),kP=akb(mRc,'GodRaysGenerateShader_Resources_default_InlineClientBundleGenerator$1',1276),lP=akb(mRc,'GodRaysGenerateShader_Resources_default_InlineClientBundleGenerator$2',1277),iP=akb(mRc,'GodRaysCombineShader_Resources_default_InlineClientBundleGenerator',1269),gP=akb(mRc,'GodRaysCombineShader_Resources_default_InlineClientBundleGenerator$1',1270),hP=akb(mRc,'GodRaysCombineShader_Resources_default_InlineClientBundleGenerator$2',1271),qP=akb(mRc,'GodraysFakeSunShader_Resources_default_InlineClientBundleGenerator',1281),oP=akb(mRc,'GodraysFakeSunShader_Resources_default_InlineClientBundleGenerator$1',1282),pP=akb(mRc,'GodraysFakeSunShader_Resources_default_InlineClientBundleGenerator$2',1283),FG=akb(BSc,'DepthShader_Resources_default_InlineClientBundleGenerator',750),DG=akb(BSc,'DepthShader_Resources_default_InlineClientBundleGenerator$1',751),EG=akb(BSc,'DepthShader_Resources_default_InlineClientBundleGenerator$2',752);FMc(Ii)(40);