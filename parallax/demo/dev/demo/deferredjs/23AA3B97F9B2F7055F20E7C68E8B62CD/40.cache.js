function aLb(){}
function eLb(){}
function hLb(){}
function Gxc(){}
function Kxc(){}
function Nxc(){}
function Zxc(){}
function byc(){}
function eyc(){}
function qyc(){}
function uyc(){}
function xyc(){}
function k9b(a,b){a.c=b}
function kLb(){kLb=yQc;_Kb=new hLb}
function jLb(){jLb=yQc;$Kb=new eLb}
function YKb(){YKb=yQc;XKb=new aLb}
function gyc(){gyc=yQc;Xxc=new byc}
function hyc(){hyc=yQc;Yxc=new eyc}
function myc(){myc=yQc;lyc=new qyc}
function zyc(){zyc=yQc;oyc=new uyc}
function Ayc(){Ayc=yQc;pyc=new xyc}
function Cxc(){Cxc=yQc;Bxc=new Gxc}
function Pxc(){Pxc=yQc;Exc=new Kxc}
function Qxc(){Qxc=yQc;Fxc=new Nxc}
function Vxc(){Vxc=yQc;Uxc=new Zxc}
function ktc(a,b){this.a=a;this.b=b}
function AHb(a,b){lIb(a,b);zHb(a,false)}
function TKb(){DJb.call(this,(YKb(),XKb))}
function zxc(){DJb.call(this,(Cxc(),Bxc))}
function Sxc(){DJb.call(this,(Vxc(),Uxc))}
function jyc(){DJb.call(this,(myc(),lyc))}
function V0b(){x$b.call(this);this.a=false;this.b=1}
function gtc(){Fac.call(this);this.t=new a7b(0,1000,-1000);this.r=new _6b}
function T6b(a,b){var c;c=new j5b;h5b(c,b.p,Y4b(c,b.X));return L6b(a,c)}
var wZc='bgColor',yZc='fAspect',vZc='fGodRayIntensity',zZc='fStepSize',mZc='mFar',lZc='mNear',BZc='tColors',CZc='tGodRays',AZc='tInput',xZc='vSunPositionScreenSpace',DZc='varying vec2 vUv;\n\nvoid main() {\n\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}';GU(749,731,WRc,TKb);_.Ld=function UKb(){rJb(this,lZc,new TNb((kOb(),YNb),new kkb(1)));rJb(this,mZc,new TNb(YNb,new kkb(2000)));rJb(this,XXc,new TNb(YNb,new kkb(1)))};_.Md=function VKb(a){var b,c;c=new vrb(fu(BS,DQc,1,[nZc]));b=new vrb(fu(BS,DQc,1,[oZc]));AJb(this,IJb(a,fu(ES,DQc,173,[c,b])))};_.Nd=function WKb(a){var b,c;c=new vrb(fu(BS,DQc,1,[pZc,qZc]));b=new vrb(fu(BS,DQc,1,[rZc,sZc,tZc]));BJb(this,IJb(a,fu(ES,DQc,173,[c,b])))};var XKb;GU(750,1,{},aLb);_.Od=function bLb(){return jLb(),$Kb};_.Pd=function cLb(){return kLb(),_Kb};var $Kb,_Kb;GU(751,1,{},eLb);_.nc=function fLb(){return 'uniform float mNear;\r\nuniform float mFar;\r\nuniform float opacity;\r\n\r\n[*]\r\n\r\nvoid main() {\r\n\r\n[*]\r\n\r\n\t#ifdef USE_LOGDEPTHBUF_EXT\r\n\r\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\r\n\r\n\t#else\r\n\r\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\r\n\r\n\t#endif\r\n\r\n\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\r\n\tgl_FragColor = vec4( vec3( color ), opacity );\r\n\r\n}'};GU(752,1,{},hLb);_.nc=function iLb(){return uZc};GU(921,914,{280:1,283:1},V0b);_.Ne=function W0b(){var a;return a=new V0b,f$b(this,a),a.a=this.a,a.b=this.b,a};_.Oe=function X0b(){return new TKb};_.Ke=function Y0b(){return this.b};_.Le=function Z0b(){return this.a};_.Pe=function $0b(a,b){var c;k$b(this,b);c=j$b(this).i;if(a.cZ==PG){RNb(pu(c.a[lZc],227),new kkb(pu(a,237).d));RNb(pu(c.a[mZc],227),new kkb(pu(a,237).b))}RNb(pu(c.a[XXc],227),new kkb(this.Z))};_.a=false;_.b=0;GU(1229,1,hSc);_.zb=function etc(){fac(this.b,new gtc(this.a))};GU(1230,973,{337:1},gtc);_.nb=function htc(){var a,b,c,d;this.a=new oRb(70,GHb(this.G.k),1,3000);Y6b(this.a._,200);this.b=new V0b;c=new q0b;k0b(c,new f4b(0));o0b(c,($_b(),X_b));new RAc('./static/models/obj/tree/tree.js',new ktc(this,c));a=new LXb(1,20,10);this.s=new y8b(a,c);V6b(this.s.eb,20);nQb(this.H,this.s);oIb(this.G.k,false);$Hb(this.G.k,false);bIb(this.G.k,1297,1);this.j=new l9b;this.i=new bRb(this.G.k.Z,this.G.k.Y,-10000,10000);Y6b(this.i._,100);nQb(this.j,this.i);this.n=new nPb(this.G.k.Z,this.G.k.Y);FOb(this.n,(qFb(),kFb));DOb(this.n,(fFb(),dFb));AOb(this.n,(bDb(),aDb));this.o=new nPb(this.G.k.Z,this.G.k.Y);FOb(this.o,kFb);DOb(this.o,dFb);AOb(this.o,aDb);d=~~(this.G.k.Z/4);b=~~(this.G.k.Y/4);this.p=new nPb(d,b);FOb(this.p,kFb);DOb(this.p,dFb);AOb(this.p,aDb);this.q=new nPb(d,b);FOb(this.q,kFb);DOb(this.q,dFb);AOb(this.q,aDb);this.e=new r3b(new Sxc);this.c=new r3b(new zxc);RNb(pu(OSb(j$b(this.c).i,vZc),227),new kkb(0.75));this.d=new r3b(new jyc);c4b(pu(pu(OSb(j$b(this.d).i,wZc),227).d,294),1297);c4b(pu(pu(OSb(j$b(this.d).i,DYc),227).d,294),16772608);this.k=new y8b(new AXb(this.G.k.Z,this.G.k.Y),this.e);Y6b(this.k._,-9900);nQb(this.j,this.k)};_.ob=function itc(a){var b,c,d,e,f,g;f=a/4000;j6b(this.s._,200*klb(f));Y6b(this.s._,200*tlb(f)-100);e6b(this.a._,(this.f-this.a._.c)*0.036);f6b(this.a._,(-this.g-this.a._.d)*0.036);MQb(this.a,this.H._);T6b(this.r.jf(this.t),this.a);j6b(this.r,(this.r.c+1)/2);k6b(this.r,(this.r.d+1)/2);i6b(pu(pu(OSb(j$b(this.e).i,xZc),227).d,298),this.r.c,this.r.d);i6b(pu(pu(OSb(j$b(this.d).i,xZc),227).d,298),this.r.c,this.r.d);AHb(this.G.k,this.n);g=this.G.k.Z;b=this.G.k.Y;d=0.74*b;e=0.74*b;j6b(this.r,this.r.c*g);k6b(this.r,this.r.d*b);mIb(this.G.k,xu(this.r.c-e/2),xu(this.r.d-d/2),xu(e),xu(d));FHb(this.G.k,true);RNb(pu(OSb(j$b(this.d).i,yZc),227),new kkb(g/b));k9b(this.j,this.d);SHb(this.G.k,this.j,this.i,this.n,false);FHb(this.G.k,false);k9b(this.H,null);SHb(this.G.k,this.H,this.a,this.n,false);k9b(this.H,this.b);SHb(this.G.k,this.H,this.a,this.o,true);c=qlb(6,-1);RNb(pu(OSb(j$b(this.e).i,zZc),227),new kkb(c));RNb(pu(OSb(j$b(this.e).i,AZc),227),this.o);k9b(this.j,this.e);SHb(this.G.k,this.j,this.i,this.q,false);c=qlb(6,-2);RNb(pu(OSb(j$b(this.e).i,zZc),227),new kkb(c));RNb(pu(OSb(j$b(this.e).i,AZc),227),this.q);SHb(this.G.k,this.j,this.i,this.p,false);c=qlb(6,-3);RNb(pu(OSb(j$b(this.e).i,zZc),227),new kkb(c));RNb(pu(OSb(j$b(this.e).i,AZc),227),this.p);SHb(this.G.k,this.j,this.i,this.q,false);RNb(pu(OSb(j$b(this.c).i,BZc),227),this.n);RNb(pu(OSb(j$b(this.c).i,CZc),227),this.q);k9b(this.j,this.c);SHb(this.G.k,this.j,this.i,null,false);k9b(this.j,null)};_.f=0;_.g=0;GU(1231,1,{},ktc);_.zf=function ltc(a,b){var c;c=new y8b(b,this.b);W6b(c._,0,-150,-150);V6b(c.eb,400);c.W=false;T4b(c.V,c._,c.ab,c.eb);c.Y=true;nQb(this.a.H,c)};GU(1320,731,WRc,zxc);_.Ld=function Axc(){rJb(this,BZc,new SNb((kOb(),cOb)));rJb(this,CZc,new SNb(cOb));rJb(this,vZc,new TNb(YNb,new kkb(0.69)));rJb(this,xZc,new TNb(eOb,new m6b(0.5,0.5)))};var Bxc;GU(1321,1,{},Gxc);_.Od=function Hxc(){return Pxc(),Exc};_.Pd=function Ixc(){return Qxc(),Fxc};var Exc,Fxc;GU(1322,1,{},Kxc);_.nc=function Lxc(){return 'varying vec2 vUv;\n\nuniform sampler2D tColors;\nuniform sampler2D tGodRays;\n\nuniform vec2 vSunPositionScreenSpace;\nuniform float fGodRayIntensity;\n\nvoid main() {\n\n\t// Since THREE.MeshDepthMaterial renders foreground objects white and background\n\t// objects black, the god-rays will be white streaks. Therefore value is inverted\n\t// before being combined with tColors\n\n\tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );\n\tgl_FragColor.a = 1.0;\n\n}\n'};GU(1323,1,{},Nxc);_.nc=function Oxc(){return DZc};GU(1326,731,WRc,Sxc);_.Ld=function Txc(){rJb(this,AZc,new SNb((kOb(),cOb)));rJb(this,zZc,new TNb(YNb,new kkb(1)));rJb(this,xZc,new TNb(eOb,new m6b(0.5,0.5)))};var Uxc;GU(1327,1,{},Zxc);_.Od=function $xc(){return gyc(),Xxc};_.Pd=function _xc(){return hyc(),Yxc};var Xxc,Yxc;GU(1328,1,{},byc);_.nc=function cyc(){return "#define TAPS_PER_PASS 6.0\n\nvarying vec2 vUv;\n\nuniform sampler2D tInput;\n\nuniform vec2 vSunPositionScreenSpace;\nuniform float fStepSize; // filter step size\n\nvoid main() {\n\n\t// delta from current pixel to \"sun\" position\n\n\tvec2 delta = vSunPositionScreenSpace - vUv;\n\tfloat dist = length( delta );\n\n\t// Step vector (uv space)\n\n\tvec2 stepv = fStepSize * delta / dist;\n\n\t// Number of iterations between pixel and sun\n\n\tfloat iters = dist/fStepSize;\n\n\tvec2 uv = vUv.xy;\n\tfloat col = 0.0;\n\n\t// This breaks ANGLE in Chrome 22\n\t//\t- see http://code.google.com/p/chromium/issues/detail?id=153105\n\n/*\n\t// Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),\n\t// so i've just left the loop\n\n\tfor ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\n\n\t\t\t\t\t// Accumulate samples, making sure we dont walk past the light source.\n\n\t\t\t\t\t// The check for uv.y < 1 would not be necessary with \"border\" UV wrap\n\t\t\t\t\t// mode, with a black border colour. I don't think this is currently\n\t\t\t\t\t// exposed by three.js. As a result there might be artifacts when the\n\t\t\t\t\t// sun is to the left, right or bottom of screen as these cases are\n\t\t\t\t\t// not specifically handled.\n\n\t\tcol += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );\n\t\tuv += stepv;\n\n\t}\n*/\n\n\t// Unrolling loop manually makes it work in ANGLE\n\n\tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\n\tuv += stepv;\n\n\tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\n\tuv += stepv;\n\n\tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\n\tuv += stepv;\n\n\tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\n\tuv += stepv;\n\n\tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\n\tuv += stepv;\n\n\tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\n\tuv += stepv;\n\n\t// Should technically be dividing by 'iters', but 'TAPS_PER_PASS' smooths out\n\t// objectionable artifacts, in particular near the sun position. The side\n\t// effect is that the result is darker than it should be around the sun, as\n\t// TAPS_PER_PASS is greater than the number of samples actually accumulated.\n\t// When the result is inverted (in the shader 'godrays_combine', this produces\n\t// a slight bright spot at the position of the sun, even when it is occluded.\n\n\tgl_FragColor = vec4( col/TAPS_PER_PASS );\n\tgl_FragColor.a = 1.0;\n\n}\n"};GU(1329,1,{},eyc);_.nc=function fyc(){return DZc};GU(1332,731,WRc,jyc);_.Ld=function kyc(){rJb(this,xZc,new TNb((kOb(),eOb),new m6b(0.5,0.5)));rJb(this,yZc,new TNb(YNb,new kkb(1)));rJb(this,DYc,new TNb(XNb,new f4b(16772608)));rJb(this,wZc,new TNb(XNb,new f4b(0)))};var lyc;GU(1333,1,{},qyc);_.Od=function ryc(){return zyc(),oyc};_.Pd=function syc(){return Ayc(),pyc};var oyc,pyc;GU(1334,1,{},uyc);_.nc=function vyc(){return 'varying vec2 vUv;\n\nuniform vec2 vSunPositionScreenSpace;\nuniform float fAspect;\n\nuniform vec3 sunColor;\nuniform vec3 bgColor;\n\nvoid main() {\n\n\tvec2 diff = vUv - vSunPositionScreenSpace;\n\n\t// Correct for aspect ratio\n\n\tdiff.x *= fAspect;\n\n\tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );\n\tprop = 0.35 * pow( 1.0 - prop, 3.0 );\n\n\tgl_FragColor.xyz = mix( sunColor, bgColor, 1.0 - prop );\n\tgl_FragColor.w = 1.0;\n\n}\n'};GU(1335,1,{},xyc);_.nc=function yyc(){return DZc};var aO=$jb(bXc,'PostprocessingGodrays$DemoScene',1230),_N=$jb(bXc,'PostprocessingGodrays$DemoScene$1',1231),KI=$jb(EZc,'MeshDepthMaterial',921),IO=$jb(TWc,'GodRaysGenerateShader',1326),EO=$jb(TWc,'GodRaysCombineShader',1320),MO=$jb(TWc,'GodraysFakeSunShader',1332),XF=$jb(hYc,'DepthShader',749),HO=$jb(TWc,'GodRaysGenerateShader_Resources_default_InlineClientBundleGenerator',1327),FO=$jb(TWc,'GodRaysGenerateShader_Resources_default_InlineClientBundleGenerator$1',1328),GO=$jb(TWc,'GodRaysGenerateShader_Resources_default_InlineClientBundleGenerator$2',1329),DO=$jb(TWc,'GodRaysCombineShader_Resources_default_InlineClientBundleGenerator',1321),BO=$jb(TWc,'GodRaysCombineShader_Resources_default_InlineClientBundleGenerator$1',1322),CO=$jb(TWc,'GodRaysCombineShader_Resources_default_InlineClientBundleGenerator$2',1323),LO=$jb(TWc,'GodraysFakeSunShader_Resources_default_InlineClientBundleGenerator',1333),JO=$jb(TWc,'GodraysFakeSunShader_Resources_default_InlineClientBundleGenerator$1',1334),KO=$jb(TWc,'GodraysFakeSunShader_Resources_default_InlineClientBundleGenerator$2',1335),WF=$jb(hYc,'DepthShader_Resources_default_InlineClientBundleGenerator',750),UF=$jb(hYc,'DepthShader_Resources_default_InlineClientBundleGenerator$1',751),VF=$jb(hYc,'DepthShader_Resources_default_InlineClientBundleGenerator$2',752);vSc(xi)(40);