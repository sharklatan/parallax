function bKb(){}
function fKb(){}
function iKb(){}
function ivc(){}
function evc(){}
function lvc(){}
function uuc(){}
function yuc(){}
function Buc(){}
function Nuc(){}
function Ruc(){}
function Uuc(){}
function M8b(a,b){a.c=b}
function lKb(){lKb=TKc;aKb=new iKb}
function kKb(){kKb=TKc;_Jb=new fKb}
function ZJb(){ZJb=TKc;YJb=new bKb}
function quc(){quc=TKc;puc=new uuc}
function Duc(){Duc=TKc;suc=new yuc}
function Euc(){Euc=TKc;tuc=new Buc}
function Juc(){Juc=TKc;Iuc=new Nuc}
function Wuc(){Wuc=TKc;Luc=new Ruc}
function Xuc(){Xuc=TKc;Muc=new Uuc}
function avc(){avc=TKc;_uc=new evc}
function nvc(){nvc=TKc;cvc=new ivc}
function ovc(){ovc=TKc;dvc=new lvc}
function isc(a,b){this.a=a;this.b=b}
function BGb(a,b){mHb(a,b);AGb(a,false)}
function UJb(){EIb.call(this,(ZJb(),YJb))}
function nuc(){EIb.call(this,(quc(),puc))}
function Guc(){EIb.call(this,(Juc(),Iuc))}
function Zuc(){EIb.call(this,(avc(),_uc))}
function I0b(){k$b.call(this);this.a=false;this.b=1}
function esc(){gac.call(this);this.t=new Q6b(0,1000,-1000);this.r=new P6b}
function H6b(a,b){var c;c=new Z4b;X4b(c,b.p,M4b(c,b.X));return z6b(a,c)}
var YTc='bgColor',$Tc='fAspect',XTc='fGodRayIntensity',_Tc='fStepSize',OTc='mFar',NTc='mNear',bUc='tColors',cUc='tGodRays',aUc='tInput',ZTc='vSunPositionScreenSpace',dUc='varying vec2 vUv;\n\nvoid main() {\n\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}';hU(748,730,pMc,UJb);_.Ld=function VJb(){sIb(this,NTc,new UMb((lNb(),ZMb),new Ojb(1)));sIb(this,OTc,new UMb(ZMb,new Ojb(2000)));sIb(this,sSc,new UMb(ZMb,new Ojb(1)))};_.Md=function WJb(a){var b,c;c=new _qb(fu(dS,YKc,1,[PTc]));b=new _qb(fu(dS,YKc,1,[QTc]));BIb(this,JIb(a,fu(gS,YKc,173,[c,b])))};_.Nd=function XJb(a){var b,c;c=new _qb(fu(dS,YKc,1,[RTc,STc]));b=new _qb(fu(dS,YKc,1,[TTc,UTc,VTc]));CIb(this,JIb(a,fu(gS,YKc,173,[c,b])))};var YJb;hU(749,1,{},bKb);_.Od=function cKb(){return kKb(),_Jb};_.Pd=function dKb(){return lKb(),aKb};var _Jb,aKb;hU(750,1,{},fKb);_.nc=function gKb(){return 'uniform float mNear;\r\nuniform float mFar;\r\nuniform float opacity;\r\n\r\n[*]\r\n\r\nvoid main() {\r\n\r\n[*]\r\n\r\n\t#ifdef USE_LOGDEPTHBUF_EXT\r\n\r\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\r\n\r\n\t#else\r\n\r\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\r\n\r\n\t#endif\r\n\r\n\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\r\n\tgl_FragColor = vec4( vec3( color ), opacity );\r\n\r\n}'};hU(751,1,{},iKb);_.nc=function jKb(){return WTc};hU(815,812,{78:1,186:1,235:1,236:1,249:1});_.Zd=function fQb(){return this.b};_.$d=function gQb(){return this.d};hU(816,812,{78:1,186:1,235:1,237:1,249:1});_.Zd=function tQb(){return this.b};_.$d=function uQb(){return this.g};hU(927,920,{279:1,282:1},I0b);_.Re=function J0b(){var a;return a=new I0b,UZb(this,a),a.a=this.a,a.b=this.b,a};_.Se=function K0b(){return new UJb};_.Oe=function L0b(){return this.b};_.Pe=function M0b(){return this.a};_.Te=function N0b(a,b){var c;ZZb(this,b);c=YZb(this).i;if(su(a,235)){SMb(pu(c.a[NTc],225),new Ojb(pu(a,235).$d()));SMb(pu(c.a[OTc],225),new Ojb(pu(a,235).Zd()))}SMb(pu(c.a[sSc],225),new Ojb(this.Z))};_.a=false;_.b=0;hU(1239,1,DMc);_.zb=function csc(){I9b(this.b,new esc(this.a))};hU(1240,978,{336:1},esc);_.nb=function fsc(){var a,b,c,d;this.a=new rQb(70,HGb(this.G.k),1,3000);M6b(this.a._,200);this.b=new I0b;c=new d0b;Z_b(c,new V3b(0));b0b(c,(N_b(),K_b));new Fxc('./static/models/obj/tree/tree.js',new isc(this,c));a=new TWb(1,20,10);this.s=new oYb(a,c);J6b(this.s.eb,20);oPb(this.H,this.s);pHb(this.G.k,false);_Gb(this.G.k,false);cHb(this.G.k,1297,1);this.j=new N8b;this.i=new cQb(this.G.k.Z,this.G.k.Y,-10000,10000);M6b(this.i._,100);oPb(this.j,this.i);this.n=new oOb(this.G.k.Z,this.G.k.Y);GNb(this.n,(sEb(),mEb));ENb(this.n,(hEb(),fEb));BNb(this.n,(DCb(),CCb));this.o=new oOb(this.G.k.Z,this.G.k.Y);GNb(this.o,mEb);ENb(this.o,fEb);BNb(this.o,CCb);d=~~(this.G.k.Z/4);b=~~(this.G.k.Y/4);this.p=new oOb(d,b);GNb(this.p,mEb);ENb(this.p,fEb);BNb(this.p,CCb);this.q=new oOb(d,b);GNb(this.q,mEb);ENb(this.q,fEb);BNb(this.q,CCb);this.e=new e3b(new Guc);this.c=new e3b(new nuc);SMb(pu(WRb(YZb(this.c).i,XTc),225),new Ojb(0.75));this.d=new e3b(new Zuc);S3b(pu(pu(WRb(YZb(this.d).i,YTc),225).d,293),1297);S3b(pu(pu(WRb(YZb(this.d).i,fTc),225).d,293),16772608);this.k=new oYb(new IWb(this.G.k.Z,this.G.k.Y),this.e);M6b(this.k._,-9900);oPb(this.j,this.k)};_.ob=function gsc(a){var b,c,d,e,f,g;f=a/4000;Z5b(this.s._,200*Okb(f));M6b(this.s._,200*Xkb(f)-100);U5b(this.a._,(this.f-this.a._.c)*0.036);V5b(this.a._,(-this.g-this.a._.d)*0.036);NPb(this.a,this.H._);H6b(this.r.nf(this.t),this.a);Z5b(this.r,(this.r.c+1)/2);$5b(this.r,(this.r.d+1)/2);Y5b(pu(pu(WRb(YZb(this.e).i,ZTc),225).d,297),this.r.c,this.r.d);Y5b(pu(pu(WRb(YZb(this.d).i,ZTc),225).d,297),this.r.c,this.r.d);BGb(this.G.k,this.n);g=this.G.k.Z;b=this.G.k.Y;d=0.74*b;e=0.74*b;Z5b(this.r,this.r.c*g);$5b(this.r,this.r.d*b);nHb(this.G.k,xu(this.r.c-e/2),xu(this.r.d-d/2),xu(e),xu(d));GGb(this.G.k,true);SMb(pu(WRb(YZb(this.d).i,$Tc),225),new Ojb(g/b));M8b(this.j,this.d);TGb(this.G.k,this.j,this.i,this.n,false);GGb(this.G.k,false);M8b(this.H,null);TGb(this.G.k,this.H,this.a,this.n,false);M8b(this.H,this.b);TGb(this.G.k,this.H,this.a,this.o,true);c=Ukb(6,-1);SMb(pu(WRb(YZb(this.e).i,_Tc),225),new Ojb(c));SMb(pu(WRb(YZb(this.e).i,aUc),225),this.o);M8b(this.j,this.e);TGb(this.G.k,this.j,this.i,this.q,false);c=Ukb(6,-2);SMb(pu(WRb(YZb(this.e).i,_Tc),225),new Ojb(c));SMb(pu(WRb(YZb(this.e).i,aUc),225),this.q);TGb(this.G.k,this.j,this.i,this.p,false);c=Ukb(6,-3);SMb(pu(WRb(YZb(this.e).i,_Tc),225),new Ojb(c));SMb(pu(WRb(YZb(this.e).i,aUc),225),this.p);TGb(this.G.k,this.j,this.i,this.q,false);SMb(pu(WRb(YZb(this.c).i,bUc),225),this.n);SMb(pu(WRb(YZb(this.c).i,cUc),225),this.q);M8b(this.j,this.c);TGb(this.G.k,this.j,this.i,null,false);M8b(this.j,null)};_.f=0;_.g=0;hU(1241,1,{},isc);_.Bf=function jsc(a,b){var c;c=new oYb(b,this.b);K6b(c._,0,-150,-150);J6b(c.eb,400);c.W=false;H4b(c.V,c._,c.ab,c.eb);c.Y=true;oPb(this.a.H,c)};hU(1277,730,pMc,nuc);_.Ld=function ouc(){sIb(this,bUc,new TMb((lNb(),dNb)));sIb(this,cUc,new TMb(dNb));sIb(this,XTc,new UMb(ZMb,new Ojb(0.69)));sIb(this,ZTc,new UMb(fNb,new a6b(0.5,0.5)))};var puc;hU(1278,1,{},uuc);_.Od=function vuc(){return Duc(),suc};_.Pd=function wuc(){return Euc(),tuc};var suc,tuc;hU(1279,1,{},yuc);_.nc=function zuc(){return 'varying vec2 vUv;\n\nuniform sampler2D tColors;\nuniform sampler2D tGodRays;\n\nuniform vec2 vSunPositionScreenSpace;\nuniform float fGodRayIntensity;\n\nvoid main() {\n\n\t// Since THREE.MeshDepthMaterial renders foreground objects white and background\n\t// objects black, the god-rays will be white streaks. Therefore value is inverted\n\t// before being combined with tColors\n\n\tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );\n\tgl_FragColor.a = 1.0;\n\n}\n'};hU(1280,1,{},Buc);_.nc=function Cuc(){return dUc};hU(1283,730,pMc,Guc);_.Ld=function Huc(){sIb(this,aUc,new TMb((lNb(),dNb)));sIb(this,_Tc,new UMb(ZMb,new Ojb(1)));sIb(this,ZTc,new UMb(fNb,new a6b(0.5,0.5)))};var Iuc;hU(1284,1,{},Nuc);_.Od=function Ouc(){return Wuc(),Luc};_.Pd=function Puc(){return Xuc(),Muc};var Luc,Muc;hU(1285,1,{},Ruc);_.nc=function Suc(){return "#define TAPS_PER_PASS 6.0\n\nvarying vec2 vUv;\n\nuniform sampler2D tInput;\n\nuniform vec2 vSunPositionScreenSpace;\nuniform float fStepSize; // filter step size\n\nvoid main() {\n\n\t// delta from current pixel to \"sun\" position\n\n\tvec2 delta = vSunPositionScreenSpace - vUv;\n\tfloat dist = length( delta );\n\n\t// Step vector (uv space)\n\n\tvec2 stepv = fStepSize * delta / dist;\n\n\t// Number of iterations between pixel and sun\n\n\tfloat iters = dist/fStepSize;\n\n\tvec2 uv = vUv.xy;\n\tfloat col = 0.0;\n\n\t// This breaks ANGLE in Chrome 22\n\t//\t- see http://code.google.com/p/chromium/issues/detail?id=153105\n\n/*\n\t// Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),\n\t// so i've just left the loop\n\n\tfor ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\n\n\t\t\t\t\t// Accumulate samples, making sure we dont walk past the light source.\n\n\t\t\t\t\t// The check for uv.y < 1 would not be necessary with \"border\" UV wrap\n\t\t\t\t\t// mode, with a black border colour. I don't think this is currently\n\t\t\t\t\t// exposed by three.js. As a result there might be artifacts when the\n\t\t\t\t\t// sun is to the left, right or bottom of screen as these cases are\n\t\t\t\t\t// not specifically handled.\n\n\t\tcol += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );\n\t\tuv += stepv;\n\n\t}\n*/\n\n\t// Unrolling loop manually makes it work in ANGLE\n\n\tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\n\tuv += stepv;\n\n\tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\n\tuv += stepv;\n\n\tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\n\tuv += stepv;\n\n\tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\n\tuv += stepv;\n\n\tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\n\tuv += stepv;\n\n\tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\n\tuv += stepv;\n\n\t// Should technically be dividing by 'iters', but 'TAPS_PER_PASS' smooths out\n\t// objectionable artifacts, in particular near the sun position. The side\n\t// effect is that the result is darker than it should be around the sun, as\n\t// TAPS_PER_PASS is greater than the number of samples actually accumulated.\n\t// When the result is inverted (in the shader 'godrays_combine', this produces\n\t// a slight bright spot at the position of the sun, even when it is occluded.\n\n\tgl_FragColor = vec4( col/TAPS_PER_PASS );\n\tgl_FragColor.a = 1.0;\n\n}\n"};hU(1286,1,{},Uuc);_.nc=function Vuc(){return dUc};hU(1289,730,pMc,Zuc);_.Ld=function $uc(){sIb(this,ZTc,new UMb((lNb(),fNb),new a6b(0.5,0.5)));sIb(this,$Tc,new UMb(ZMb,new Ojb(1)));sIb(this,fTc,new UMb(YMb,new V3b(16772608)));sIb(this,YTc,new UMb(YMb,new V3b(0)))};var _uc;hU(1290,1,{},evc);_.Od=function fvc(){return nvc(),cvc};_.Pd=function gvc(){return ovc(),dvc};var cvc,dvc;hU(1291,1,{},ivc);_.nc=function jvc(){return 'varying vec2 vUv;\n\nuniform vec2 vSunPositionScreenSpace;\nuniform float fAspect;\n\nuniform vec3 sunColor;\nuniform vec3 bgColor;\n\nvoid main() {\n\n\tvec2 diff = vUv - vSunPositionScreenSpace;\n\n\t// Correct for aspect ratio\n\n\tdiff.x *= fAspect;\n\n\tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );\n\tprop = 0.35 * pow( 1.0 - prop, 3.0 );\n\n\tgl_FragColor.xyz = mix( sunColor, bgColor, 1.0 - prop );\n\tgl_FragColor.w = 1.0;\n\n}\n'};hU(1292,1,{},lvc);_.nc=function mvc(){return dUc};var iO=Cjb(zRc,'PostprocessingGodrays$DemoScene',1240),hO=Cjb(zRc,'PostprocessingGodrays$DemoScene$1',1241),OI=Cjb(eUc,'MeshDepthMaterial',927),MO=Cjb(pRc,'GodRaysGenerateShader',1283),IO=Cjb(pRc,'GodRaysCombineShader',1277),QO=Cjb(pRc,'GodraysFakeSunShader',1289),VF=Cjb(ESc,'DepthShader',748),LO=Cjb(pRc,'GodRaysGenerateShader_Resources_default_InlineClientBundleGenerator',1284),JO=Cjb(pRc,'GodRaysGenerateShader_Resources_default_InlineClientBundleGenerator$1',1285),KO=Cjb(pRc,'GodRaysGenerateShader_Resources_default_InlineClientBundleGenerator$2',1286),HO=Cjb(pRc,'GodRaysCombineShader_Resources_default_InlineClientBundleGenerator',1278),FO=Cjb(pRc,'GodRaysCombineShader_Resources_default_InlineClientBundleGenerator$1',1279),GO=Cjb(pRc,'GodRaysCombineShader_Resources_default_InlineClientBundleGenerator$2',1280),PO=Cjb(pRc,'GodraysFakeSunShader_Resources_default_InlineClientBundleGenerator',1290),NO=Cjb(pRc,'GodraysFakeSunShader_Resources_default_InlineClientBundleGenerator$1',1291),OO=Cjb(pRc,'GodraysFakeSunShader_Resources_default_InlineClientBundleGenerator$2',1292),UF=Cjb(ESc,'DepthShader_Resources_default_InlineClientBundleGenerator',749),SF=Cjb(ESc,'DepthShader_Resources_default_InlineClientBundleGenerator$1',750),TF=Cjb(ESc,'DepthShader_Resources_default_InlineClientBundleGenerator$2',751);RMc(xi)(40);