function Ghb(){}
function Phb(){}
function Mhb(){}
function Uhb(){}
function Thb(){}
function Yhb(){}
function Xhb(){}
function ujb(){}
function Fjb(){}
function Cjb(){}
function Kjb(){}
function Jjb(){}
function Ojb(){}
function Njb(){}
function bsb(){}
function stb(){}
function xtb(){}
function Atb(){}
function Rtb(){}
function Vtb(){}
function qCb(){}
function Snb(a,b){a.s=b}
function sCb(){vwb.call(this)}
function Btb(){lsb.call(this,new wsb)}
function Hhb(){Hgb.call(this,(Lhb(),Khb))}
function vjb(){Hgb.call(this,(Bjb(),Ajb))}
function ttb(a){lsb.call(this,a);ksb(this,a.b)}
function ytb(){wsb.call(this);this.b=(gtb(),ftb)}
function Lhb(){Lhb=tFb;Khb=new Phb}
function _hb(){_hb=tFb;Nhb=new Uhb}
function aib(){aib=tFb;Ohb=new Yhb}
function Bjb(){Bjb=tFb;Ajb=new Fjb}
function Rjb(){Rjb=tFb;Djb=new Kjb}
function Sjb(){Sjb=tFb;Ejb=new Ojb}
function csb(){Trb.call(this,16777215);this.c=1;this.b=0;new spb(0,0,0)}
function Stb(a){rsb.call(this,a);this.b=a.b;this.c=a.d;this.e=a.g;this.d=a.f;this.k=null;this.i=a.c;ksb(this,a.e)}
function Wtb(){ysb.call(this);this.b=new dnb(328965);this.g=new dnb(1118481);this.d=new dnb(0);this.c=(zlb(),ylb);this.e=(gtb(),ftb)}
function rCb(){var a,b,c,d,e,f,g,i;a=$doc.createElement(WJb);a.width=256;a.height=256;b=a.getContext(XJb);d=b.getImageData(0,0,256,256);i=0;for(c=0,e=0,f=d.data.length;c<f;c+=4,++e){g=e%64;i=g==0?i+1:i;d.data[c]=255;d.data[c+1]=255;d.data[c+2]=255;d.data[c+3]=mp(Math.floor(g^i))}b.putImageData(d,0,0);return a}
_=Hhb.prototype=Ghb.prototype=new Cgb;_.gC=function Ihb(){return rw};_.Xc=function Jhb(){Egb(this,'mNear',new Ujb((nkb(),_jb),new TW(1)));Egb(this,'mFar',new Ujb(_jb,new TW(2000)));Egb(this,zJb,new Ujb(_jb,new TW(1)))};var Khb;_=Phb.prototype=Mhb.prototype=new Jb;_.gC=function Qhb(){return qw};_.$c=function Rhb(){return _hb(),Nhb};_._c=function Shb(){return aib(),Ohb};var Nhb=null,Ohb=null;_=Uhb.prototype=Thb.prototype=new Jb;_.gC=function Vhb(){return ow};_.Jb=function Whb(){return 'uniform float mNear;\r\nuniform float mFar;\r\nuniform float opacity;\r\n\r\nvoid main() {\r\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\r\n\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\r\n\tgl_FragColor = vec4( vec3( color ), opacity );\r\n}\r\n'};_.cM={45:1};_=Yhb.prototype=Xhb.prototype=new Jb;_.gC=function Zhb(){return pw};_.Jb=function $hb(){return 'void main() {\r\n\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n}\r\n'};_.cM={45:1};_=vjb.prototype=ujb.prototype=new Cgb;_.gC=function wjb(){return Hw};_.Xc=function xjb(){Dgb(this,(wkb(),rkb));Dgb(this,skb);Dgb(this,tkb);Dgb(this,vkb);Egb(this,AJb,new Ujb((nkb(),$jb),new dnb(16777215)));Egb(this,BJb,new Ujb($jb,new dnb(0)));Egb(this,'specular',new Ujb($jb,new dnb(1118481)));Egb(this,'shininess',new Ujb(_jb,new TW(30)));Egb(this,CJb,new Ujb(jkb,new spb(1,1,1)))};_.Yc=function yjb(a){var b,c;c=new N0(Zo(vA,{79:1,80:1,84:1,95:1},1,[BIb,DJb,EJb,FJb,CIb,'uniform vec3 ambientLightColor;\r\n\r\n#if MAX_DIR_LIGHTS > 0\r\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\r\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\r\n#endif\r\n\r\n#if MAX_POINT_LIGHTS > 0\r\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\r\n\r\n\t#ifdef PHONG_PER_PIXEL\r\n\t\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\r\n\t\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\r\n\t#else\r\n\t\tvarying vec4 vPointLight[ MAX_POINT_LIGHTS ];\r\n\t#endif\r\n#endif\r\n\r\n#if MAX_SPOT_LIGHTS > 0\r\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\r\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\r\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\r\n\tuniform float spotLightAngle[ MAX_SPOT_LIGHTS ];\r\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\r\n\r\n\t#ifdef PHONG_PER_PIXEL\r\n\t\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\r\n\t#else\r\n\t\tvarying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\r\n\t#endif\r\n\r\n\tvarying vec3 vWorldPosition;\r\n\r\n#endif\r\n\r\n#ifdef WRAP_AROUND\r\n\tuniform vec3 wrapRGB;\r\n#endif\r\n\r\nvarying vec3 vViewPosition;\r\nvarying vec3 vNormal;',DIb]));b=new N0(Zo(vA,{79:1,80:1,84:1,95:1},1,[GJb,EIb,'vec3 normal = normalize( vNormal );\r\nvec3 viewPosition = normalize( vViewPosition );\r\n\r\n#ifdef DOUBLE_SIDED\r\n\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\r\n#endif\r\n\r\n#if MAX_POINT_LIGHTS > 0\r\n\tvec3 pointDiffuse  = vec3( 0.0 );\r\n\tvec3 pointSpecular = vec3( 0.0 );\r\n\r\n\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\r\n\t\t#ifdef PHONG_PER_PIXEL\r\n\t\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\r\n\t\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\r\n\r\n\t\t\tfloat lDistance = 1.0;\r\n\t\t\tif ( pointLightDistance[ i ] > 0.0 )\r\n\t\t\t\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\r\n\r\n\t\t\tlVector = normalize( lVector );\r\n\t\t#else\r\n\t\t\tvec3 lVector = normalize( vPointLight[ i ].xyz );\r\n\t\t\tfloat lDistance = vPointLight[ i ].w;\r\n\t\t#endif\r\n\r\n\t\t// diffuse\r\n\r\n\t\tfloat dotProduct = dot( normal, lVector );\r\n\r\n\t\t#ifdef WRAP_AROUND\r\n\t\t\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\r\n\t\t\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\r\n\t\t\tvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\r\n\t\t#else\r\n\t\t\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\r\n\t\t#endif\r\n\r\n\t\tpointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\r\n\r\n\t\t// specular\r\n\r\n\t\tvec3 pointHalfVector = normalize( lVector + viewPosition );\r\n\t\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\r\n\t\tfloat pointSpecularWeight = max( pow( pointDotNormalHalf, shininess ), 0.0 );\r\n\r\n\t\t#ifdef PHYSICALLY_BASED_SHADING\r\n\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\t\t\tfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\r\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );\r\n\t\t\tpointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\r\n\t\t#else\r\n\t\t\tpointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;\r\n\t\t#endif\r\n\t}\r\n\r\n#endif\r\n\r\n#if MAX_SPOT_LIGHTS > 0\r\n\tvec3 spotDiffuse  = vec3( 0.0 );\r\n\tvec3 spotSpecular = vec3( 0.0 );\r\n\r\n\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\r\n\t\t#ifdef PHONG_PER_PIXEL\r\n\t\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\r\n\t\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\r\n\r\n\t\t\tfloat lDistance = 1.0;\r\n\t\t\tif ( spotLightDistance[ i ] > 0.0 )\r\n\t\t\t\tlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\r\n\r\n\t\t\tlVector = normalize( lVector );\r\n\t\t#else\r\n\t\t\tvec3 lVector = normalize( vSpotLight[ i ].xyz );\r\n\t\t\tfloat lDistance = vSpotLight[ i ].w;\r\n\t\t#endif\r\n\r\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\r\n\r\n\t\tif ( spotEffect > spotLightAngle[ i ] ) {\r\n\t\t\tspotEffect = pow( spotEffect, spotLightExponent[ i ] );\r\n\r\n\t\t\t// diffuse\r\n\r\n\t\t\tfloat dotProduct = dot( normal, lVector );\r\n\r\n\t\t\t#ifdef WRAP_AROUND\r\n\t\t\t\tfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\r\n\t\t\t\tfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\r\n\t\t\t\tvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\r\n\t\t\t#else\r\n\t\t\t\tfloat spotDiffuseWeight = max( dotProduct, 0.0 );\r\n\t\t\t#endif\r\n\r\n\t\t\tspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\r\n\r\n\t\t\t// specular\r\n\r\n\t\t\tvec3 spotHalfVector = normalize( lVector + viewPosition );\r\n\t\t\tfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\r\n\t\t\tfloat spotSpecularWeight = max( pow( spotDotNormalHalf, shininess ), 0.0 );\r\n\r\n\t\t\t#ifdef PHYSICALLY_BASED_SHADING\r\n\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\t\t\t\tfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\r\n\t\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );\r\n\t\t\t\tspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\r\n\t\t\t#else\r\n\t\t\t\tspotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;\r\n\t\t\t#endif\r\n\t\t}\r\n\t}\r\n\r\n#endif\r\n\r\n#if MAX_DIR_LIGHTS > 0\r\n\tvec3 dirDiffuse  = vec3( 0.0 );\r\n\tvec3 dirSpecular = vec3( 0.0 );\r\n\r\n\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\r\n\t\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\r\n\t\tvec3 dirVector = normalize( lDirection.xyz );\r\n\r\n\t\t// diffuse\r\n\r\n\t\tfloat dotProduct = dot( normal, dirVector );\r\n\r\n\t\t#ifdef WRAP_AROUND\r\n\t\t\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\r\n\t\t\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\r\n\t\t\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\r\n\t\t#else\r\n\t\t\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\r\n\t\t#endif\r\n\r\n\t\tdirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\r\n\r\n\t\t// specular\r\n\r\n\t\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\r\n\t\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\r\n\t\tfloat dirSpecularWeight = max( pow( dirDotNormalHalf, shininess ), 0.0 );\r\n\r\n\t\t#ifdef PHYSICALLY_BASED_SHADING\r\n\t\t/*\r\n\t\t\t// fresnel term from skin shader\r\n\t\t\tconst float F0 = 0.128;\r\n\t\t\tfloat base = 1.0 - dot( viewPosition, dirHalfVector );\r\n\t\t\tfloat exponential = pow( base, 5.0 );\r\n\t\t\tfloat fresnel = exponential + F0 * ( 1.0 - exponential );\r\n\t\t*/\r\n\r\n\t\t/*\r\n\t\t\t// fresnel term from fresnel shader\r\n\t\t\tconst float mFresnelBias = 0.08;\r\n\t\t\tconst float mFresnelScale = 0.3;\r\n\t\t\tconst float mFresnelPower = 5.0;\r\n\t\t\tfloat fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\r\n\t\t*/\r\n\r\n\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\t\t\tfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\r\n\t\t\t//dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\r\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\r\n\t\t\tdirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\r\n\t\t\r\n\t\t#else\r\n\t\t\tdirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;\r\n\t\t#endif\r\n\t}\r\n\r\n#endif\r\n\r\nvec3 totalDiffuse = vec3( 0.0 );\r\nvec3 totalSpecular = vec3( 0.0 );\r\n\r\n#if MAX_DIR_LIGHTS > 0\r\n\ttotalDiffuse += dirDiffuse;\r\n\ttotalSpecular += dirSpecular;\r\n#endif\r\n\r\n#if MAX_POINT_LIGHTS > 0\r\n\ttotalDiffuse += pointDiffuse;\r\n\ttotalSpecular += pointSpecular;\r\n#endif\r\n\r\n#if MAX_SPOT_LIGHTS > 0\r\n\ttotalDiffuse += spotDiffuse;\r\n\ttotalSpecular += spotSpecular;\r\n#endif\r\n\r\n#ifdef METAL\r\n\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\r\n#else\r\n\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\r\n#endif',HJb,FIb,IJb,GIb,JJb,HIb]));Fgb(this,Lgb(a,Zo(xA,{79:1,95:1},102,[c,b])))};_.Zc=function zjb(a){var b,c,d,e;e=new N0(Zo(vA,{79:1,80:1,84:1,95:1},1,[KJb,LJb,MJb,'#ifndef PHONG_PER_PIXEL\r\n\r\n\t#if MAX_POINT_LIGHTS > 0\r\n\t\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\r\n\t\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\r\n\r\n\t\tvarying vec4 vPointLight[ MAX_POINT_LIGHTS ];\r\n\t#endif\r\n\r\n\t#if MAX_SPOT_LIGHTS > 0\r\n\t\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\r\n\t\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\r\n\r\n\t\tvarying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\r\n\t#endif\r\n\r\n#endif\r\n\r\n#if MAX_SPOT_LIGHTS > 0\r\n\tvarying vec3 vWorldPosition;\r\n#endif',BIb,NJb,OJb,IIb]));b=new N0(Zo(vA,{79:1,80:1,84:1,95:1},1,[PJb,QJb,RJb,JIb]));c=new N0(Zo(vA,{79:1,80:1,84:1,95:1},1,[SJb]));d=new N0(Zo(vA,{79:1,80:1,84:1,95:1},1,['#ifndef PHONG_PER_PIXEL\r\n\r\n\t#if MAX_POINT_LIGHTS > 0\r\n\t\tfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\r\n\t\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\r\n\t\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\r\n\r\n\t\t\tfloat lDistance = 1.0;\r\n\t\t\tif ( pointLightDistance[ i ] > 0.0 )\r\n\t\t\t\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\r\n\t\t\t\r\n\t\t\tvPointLight[ i ] = vec4( lVector, lDistance );\r\n\t\t}\r\n\r\n\t#endif\r\n\r\n\t#if MAX_SPOT_LIGHTS > 0\r\n\t\tfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\r\n\t\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\r\n\t\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\r\n\r\n\t\t\tfloat lDistance = 1.0;\r\n\t\t\tif ( spotLightDistance[ i ] > 0.0 )\r\n\t\t\t\tlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\r\n\t\t\t\r\n\t\t\tvSpotLight[ i ] = vec4( lVector, lDistance );\r\n\r\n\t\t}\r\n\r\n\t#endif\r\n\r\n#endif\r\n\r\n#if MAX_SPOT_LIGHTS > 0\r\n\tvWorldPosition = mPosition.xyz;\r\n#endif',TJb,UJb,VJb,KIb]));Ggb(this,Lgb(a,Zo(xA,{79:1,95:1},102,[e,b,c,d])))};var Ajb;_=Fjb.prototype=Cjb.prototype=new Jb;_.gC=function Gjb(){return Gw};_.$c=function Hjb(){return Rjb(),Djb};_._c=function Ijb(){return Sjb(),Ejb};var Djb=null,Ejb=null;_=Kjb.prototype=Jjb.prototype=new Jb;_.gC=function Ljb(){return Ew};_.Jb=function Mjb(){return 'uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\nuniform vec3 ambient;\r\nuniform vec3 emissive;\r\nuniform vec3 specular;\r\nuniform float shininess;\r\n\r\n//[*]\r\n\t\t\t\r\nvoid main() {\r\n\tgl_FragColor = vec4( vec3 ( 1.0 ), opacity );\r\n\t\t\t\t\r\n//[*]\r\n\t\t\t\t\r\n}\r\n'};_.cM={45:1};_=Ojb.prototype=Njb.prototype=new Jb;_.gC=function Pjb(){return Fw};_.Jb=function Qjb(){return 'varying vec3 vViewPosition;\r\nvarying vec3 vNormal;\r\n\r\n//[*]\r\n\t\t\t\r\nvoid main() {\r\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\r\n\t\t\t\t\r\n//[*]\r\n\t\t\t\r\n#ifndef USE_ENVMAP\r\n\tvec4 mPosition = objectMatrix * vec4( position, 1.0 );\r\n#endif\r\n\r\nvViewPosition = -mvPosition.xyz;\r\n\t\t\t\r\n//[*]\r\n\t\t\t\r\nvNormal = transformedNormal;\r\n\r\n//[*]\r\n\r\n}\r\n'};_.cM={45:1};_=csb.prototype=bsb.prototype=new Srb;_.gC=function dsb(){return Sx};_.cM={146:1,147:1,158:1};_.b=0;_.c=0;_=ttb.prototype=stb.prototype=new fsb;_.sd=function utb(){return null};_.gC=function vtb(){return ey};_.ud=function wtb(){return new Hhb};_.cM={150:1};_=ytb.prototype=xtb.prototype=new vsb;_.gC=function ztb(){return dy};_=Btb.prototype=Atb.prototype=new fsb;_.gC=function Ctb(){return fy};_.cM={150:1,154:1};_=Stb.prototype=Rtb.prototype=new esb;_.gC=function Ttb(){return ly};_.ud=function Utb(){return new vjb};_.cM={148:1,150:1,156:1};_.b=null;_.c=null;_.d=0;_.e=null;_.f=null;_=Wtb.prototype=Vtb.prototype=new usb;_.gC=function Xtb(){return ky};_.f=30;_=lCb.prototype;_.lb=function pCb(){rwb(this.c,new sCb(this.b))};_=sCb.prototype=qCb.prototype=new uwb;_.gC=function tCb(){return Kz};_.Wc=function uCb(){g5(this,new Rmb(45,o5(this.r.D),1,2000))};_.cb=function vCb(){var a,b,c,d,e,f,g,i,j,k,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C;opb(this.q.G,0,200,800);fmb(this.t,this.q);c=new Tnb;for(i=0;i<=40;++i){b0(c.C,new spb(-500,-75,i*25-500));b0(c.C,new spb(500,-75,i*25-500));b0(c.C,new spb(i*25-500,-75,-500));b0(c.C,new spb(i*25-500,-75,500))}o=new Fsb;o.b=new dnb(16777215);o.u=0.20000000298023224;n=new Bsb(o);k=new vub(c,n,(Eub(),Cub));fmb(this.t,k);C=new Xkb(rCb());C.p=true;this.b=new l0;u=new Itb;u.k=C;u.v=true;b0(this.b,new Etb(u));v=new Itb;v.i=new dnb(14540253);v.e=(gtb(),dtb);b0(this.b,new Etb(v));z=new Wtb;z.b=new dnb(197379);z.i=new dnb(14540253);z.g=new dnb(39168);z.f=30;z.e=dtb;b0(this.b,new Stb(z));b0(this.b,new Ltb(new Ptb));q=new qtb;q.i=new dnb(16755200);q.v=true;q.r=(Qsb(),Jsb);b0(this.b,new ltb(q));w=new Itb;w.i=new dnb(14540253);w.e=ftb;b0(this.b,new Etb(w));z.k=C;z.v=true;b0(this.b,new Stb(z));y=new Ptb;y.b=ftb;b0(this.b,new Ltb(y));r=new qtb;r.i=new dnb(65450);r.x=true;b0(this.b,new ltb(r));b0(this.b,new ttb(new ytb));x=new Itb;x.i=new dnb(6710886);x.d=new dnb(16711680);x.b=new dnb(0);x.e=ftb;b0(this.b,new Etb(x));A=new Wtb;A.b=new dnb(0);A.d=new dnb(16711680);A.i=new dnb(0);A.g=new dnb(6710886);A.f=10;A.e=ftb;A.u=0.8999999761581421;A.v=true;b0(this.b,new Stb(A));s=new qtb;r.k=C;r.v=true;b0(this.b,new ltb(s));g=new Zqb(70,32,16);e=new Zqb(70,32,16);f=new Zqb(70,32,16);for(i=0,j=f.o.c;i<j;++i){b=gp(f0(f.o,i),133);b.i=0}Snb(f,this.b);b0(this.b,new Btb);this.c=new l0;for(i=0,j=this.b.c;i<j;++i){p=gp(f0(this.b,i),150);d=p.gC()==fy?f:p.O==dtb?e:g;B=new Sub(d,p);cpb(B.G,i%4*200-400);ppb(B.G,Math.floor(i/4)*200-200);cpb(B.J,Math.random()*200-100);dpb(B.J,Math.random()*200-100);ppb(B.J,Math.random()*200-100);b0(this.c,B);fmb(this.t,B)}t=new qtb;t.i=new dnb(16777215);this.d=new Sub(new Zqb(4,8,8),new ltb(t));fmb(this.t,this.d);fmb(this.t,new Wrb(1118481));a=new $rb(0.125);cpb(a.G,Math.random()-0.5);dpb(a.G,Math.random()-0.5);ppb(a.G,Math.random()-0.5);a.G.od();fmb(this.t,a);this.e=new csb;fmb(this.t,this.e)};_.Uc=function wCb(){};_.db=function xCb(a){var b,c,d,e,f;f=1.0E-4*a;cpb(this.q.G,Math.cos(f)*1000);ppb(this.q.G,Math.sin(f)*1000);vmb(this.q,this.t.G);for(b=0,c=this.c.c;b<c;++b){e=gp(f0(this.c,b),161);e.J.d+=0.009999999776482582;e.J.e+=0.004999999888241291;d=gp(f0(this.b,b),150);b>9&&ip(d,156)?$mb(gp(d,156).c,0.5400000214576721,1,0.7*(0.5+0.5*Math.sin(35*f))):b>9&&ip(d,155)&&$mb(gp(d,155).c,0.03999999910593033,1,0.7*(0.5+0.5*Math.cos(35*f)))}cpb(this.d.G,Math.sin(f*7)*300);dpb(this.d.G,Math.cos(f*5)*400);ppb(this.d.G,Math.cos(f*3)*300);cpb(this.e.G,this.d.G.d);dpb(this.e.G,this.d.G.e);ppb(this.e.G,this.d.G.c);f5(this)};_.b=null;_.c=null;_.d=null;_.e=null;var rw=yW(fJb,'ShaderDepth'),qw=yW(fJb,'ShaderDepth_Resources_default_InlineClientBundleGenerator'),ow=yW(fJb,'ShaderDepth_Resources_default_InlineClientBundleGenerator$1'),pw=yW(fJb,'ShaderDepth_Resources_default_InlineClientBundleGenerator$2'),Hw=yW(fJb,'ShaderPhong'),Gw=yW(fJb,'ShaderPhong_Resources_default_InlineClientBundleGenerator'),Ew=yW(fJb,'ShaderPhong_Resources_default_InlineClientBundleGenerator$1'),Fw=yW(fJb,'ShaderPhong_Resources_default_InlineClientBundleGenerator$2'),dy=yW(YJb,'MeshDepthMaterial$MeshDepthMaterialOptions'),fy=yW(YJb,'MeshFaceMaterial'),ky=yW(YJb,'MeshPhongMaterial$MeshPhongMaterialOptions'),Kz=yW(AIb,'MaterialsCanvas2D$DemoScene');vFb(Md)(10);