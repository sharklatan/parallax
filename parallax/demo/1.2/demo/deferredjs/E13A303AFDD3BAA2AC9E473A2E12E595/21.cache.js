function v3b(){}
function D3b(){}
function Jbc(){}
function Sbc(){}
function Pbc(){}
function Xbc(){}
function Wbc(){}
function _bc(){}
function $bc(){}
function $dc(){}
function Kdc(){}
function Vdc(){}
function Sdc(){}
function Zdc(){}
function cec(){}
function bec(){}
function x3b(){LTb.call(this)}
function E3b(a,b){this.b=a;this.c=b}
function Obc(){Obc=qic;Nbc=new Sbc}
function ccc(){ccc=qic;Qbc=new Xbc}
function dcc(){dcc=qic;Rbc=new _bc}
function Rdc(){Rdc=qic;Qdc=new Vdc}
function fec(){fec=qic;Tdc=new $dc}
function gec(){gec=qic;Udc=new cec}
function Ldc(){wrb.call(this,(Rdc(),Qdc))}
function Kbc(){wrb.call(this,(Obc(),Nbc))}
function w3b(a,b){var c,d,e,f,g,i;d=(KSb(),MSb(umc,(Rxb(),Qxb),null));d.n=4;EEb(d.y,0.998,0.998);EEb(d.x,0.001,0.001);hxb(d,(Rob(),Qob));ixb(d,Qob);$wb(d,(oob(),mob));e=MSb('./static/models/obj/leeperrysmith/Map-SPEC.jpg',Qxb,null);EEb(e.y,0.998,0.998);EEb(e.x,0.001,0.001);hxb(e,Qob);ixb(e,Qob);$wb(e,mob);c=MSb('./static/models/obj/leeperrysmith/Map-COL.jpg',Qxb,null);EEb(c.y,0.998,0.998);EEb(c.x,0.001,0.001);hxb(c,Qob);ixb(c,Qob);$wb(c,mob);g=new Ldc;i=g.j;swb(Us(i.b[wmc],133),(d4(),d4(),c4));swb(Us(i.b[xmc],133),c4);swb(Us(i.b[ymc],133),a.b.f);swb(Us(i.b[zmc],133),c);swb(Us(i.b[Amc],133),d);swb(Us(i.b[Bmc],133),e);Tzb(Us(Us(i.b[Cmc],133).e,142),10526880);Tzb(Us(Us(i.b[Dmc],133).e,142),10526880);Tzb(Us(Us(i.b[Emc],133).e,142),10526880);swb(Us(i.b[Fmc],133),new B4(0.145));swb(Us(i.b[Gmc],133),new B4(0.75));swb(Us(i.b[Hmc],133),new B4(16));UFb(Us(Us(i.b[Imc],133).e,157),0.001,0.001,0.998,0.998);f=new _Qb(g);f.d=true;a.c=new KRb(b,f);a.c.X.e=-50;hFb(a.c.ab,100);a.c.N=true;a.c.O=true;Kyb(a.C,a.c)}
var wmc='enableBump',ymc='tBeckmann',Fmc='uRoughness',Gmc='uSpecularBrightness';_=q3b.prototype;_.tb=function u3b(){HTb(this.c,new x3b(this.b))};_=x3b.prototype=v3b.prototype=new KTb;_.gC=function y3b(){return nG};_.td=function z3b(){neb(this,new Ezb(27,ffb(this.B.E),1,10000))};_.hb=function A3b(){var a,b,c,d,e,f,g,i;this.A.X.c=1200;Kyb(this.C,this.A);Kyb(this.C,new fMb(5592405));f=new rMb(16777215,1.5,1000);gFb(f.X,0,0,600);Kyb(this.C,f);g=new uMb(1);gFb(g.X,0.05,0.05,1);Kyb(this.C,g);g.X.me(700);g.N=true;g.v=true;g.F=2048;g.D=2048;g.z=200;g.y=1500;g.d=40;g.w=-0.005;g.B=0.15;b=new nMb(16777215,0.85);gFb(b.X,1,-0.5,1);Szb(b.I,0.6,0.3,1);Kyb(this.C,b);b.X.me(500);b.N=true;b.F=2048;b.D=2048;b.z=200;b.y=1500;b.f=-500;b.g=500;b.i=500;b.e=-500;b.w=-0.005;b.B=0.15;c=new nMb(16777215,0.85);gFb(c.X,1,-0.5,-1);Kyb(this.C,c);new rgc(new Kbc);d=new rgc(new Sgc);d.b=true;i=new zxb(512,512);bxb(i,(Iob(),Cob));axb(i,(wob(),uob));$wb(i,(oob(),mob));i.g=false;this.b=new igc(this.B,i);e=new yec;try{jec(e,vmc,new E3b(this,e))}catch(a){a=PJ(a);if(Ws(a,41)){zyb();jN(yyb,(RM(),PM),emc)}else throw a}mqb(this.B,5001561,1);this.B.Q=true;this.B.P=false;this.B.J=false;this.B.L=true;this.B.M=true;this.B.O=true};_.sd=function B3b(){};_.ib=function C3b(a){var b,c;b=this.d*0.001;c=this.e*0.001;if(this.c){AEb(this.c.$,0.05*(b-this.c.$.e));zEb(this.c.$,0.05*(c-this.c.$.d))}Upb(this.B)};_.cM={223:1};_.b=null;_.c=null;_.d=0;_.e=0;_=E3b.prototype=D3b.prototype=new Kb;_.gC=function F3b(){return mG};_.cf=function G3b(){w3b(this.b,this.c.c)};_.b=null;_.c=null;_=Kbc.prototype=Jbc.prototype=new irb;_.gC=function Lbc(){return QH};_.xd=function Mbc(){};_.cM={131:1};var Nbc;_=Sbc.prototype=Pbc.prototype=new Kb;_.gC=function Tbc(){return PH};_.Ad=function Ubc(){return ccc(),Qbc};_.Bd=function Vbc(){return dcc(),Rbc};var Qbc=null,Rbc=null;_=Xbc.prototype=Wbc.prototype=new Kb;_.gC=function Ybc(){return NH};_.ac=function Zbc(){return 'varying vec2 vUv;\r\n\r\nfloat PHBeckmann( float ndoth, float m ) {\r\n\r\n\tfloat alpha = acos( ndoth );\r\n\tfloat ta = tan( alpha );\r\n\r\n\tfloat val = 1.0 / ( m * m * pow( ndoth, 4.0 ) ) * exp( -( ta * ta ) / ( m * m ) );\r\n\treturn val;\r\n\r\n}\r\n\r\nfloat KSTextureCompute( vec2 tex ) {\r\n\r\n\t// Scale the value to fit within [0,1]  invert upon lookup.\r\n\r\n\treturn 0.5 * pow( PHBeckmann( tex.x, tex.y ), 0.1 );\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n\tfloat x = KSTextureCompute( vUv );\r\n\r\n\tgl_FragColor = vec4( x, x, x, 1.0 );\r\n\r\n}\r\n'};_=_bc.prototype=$bc.prototype=new Kb;_.gC=function acc(){return OH};_.ac=function bcc(){return Jmc};_=Ldc.prototype=Kdc.prototype=new irb;_.gC=function Mdc(){return VH};_.xd=function Ndc(){srb(this,Twb());srb(this,Uwb());srb(this,Vwb());lrb(this,wmc,new uwb((Owb(),Dwb),d5(0)));lrb(this,xmc,new uwb(Dwb,d5(0)));lrb(this,zmc,new twb(Gwb));lrb(this,ymc,new twb(Gwb));lrb(this,Dmc,new uwb(zwb,new Yzb(15658734)));lrb(this,Emc,new uwb(zwb,new Yzb(1118481)));lrb(this,Cmc,new uwb(zwb,new Yzb(328965)));lrb(this,Kmc,new uwb(Awb,new B4(1)));lrb(this,Fmc,new uwb(Awb,new B4(0.15)));lrb(this,Gmc,new uwb(Awb,new B4(0.75)));lrb(this,Amc,new twb(Gwb));lrb(this,Hmc,new uwb(Awb,new B4(1)));lrb(this,Bmc,new twb(Gwb));lrb(this,Imc,new uwb(Mwb,new XFb(0,0,1,1)));lrb(this,'uWrapRGB',new uwb(Kwb,new mFb(0.75,0.375,0.1875)))};_.yd=function Odc(a){var b,c;c=new Eab(Ls(_I,{87:1,99:1},1,[Lmc,Mmc,Nmc]));b=new Eab(Ls(_I,{87:1,99:1},1,[Omc,Pmc,Qmc]));urb(this,Crb(a,Ls(bJ,{87:1,99:1},106,[c,b])))};_.zd=function Pdc(a){var b,c;c=new Eab(Ls(_I,{87:1,99:1},1,[Rmc]));b=new Eab(Ls(_I,{87:1,99:1},1,[Smc]));vrb(this,Crb(a,Ls(bJ,{87:1,99:1},106,[c,b])))};_.cM={131:1};var Qdc;_=Vdc.prototype=Sdc.prototype=new Kb;_.gC=function Wdc(){return UH};_.Ad=function Xdc(){return fec(),Tdc};_.Bd=function Ydc(){return gec(),Udc};var Tdc=null,Udc=null;_=$dc.prototype=Zdc.prototype=new Kb;_.gC=function _dc(){return SH};_.ac=function aec(){return '#define USE_BUMPMAP\r\n#extension GL_OES_standard_derivatives : enable\r\n\r\nuniform bool enableBump;\r\nuniform bool enableSpecular;\r\n\r\nuniform vec3 uAmbientColor;\r\nuniform vec3 uDiffuseColor;\r\nuniform vec3 uSpecularColor;\r\nuniform float uOpacity;\r\n\r\nuniform float uRoughness;\r\nuniform float uSpecularBrightness;\r\n\r\nuniform vec3 uWrapRGB;\r\n\r\nuniform sampler2D tDiffuse;\r\nuniform sampler2D tBeckmann;\r\n\r\nuniform sampler2D specularMap;\r\n\r\nvarying vec3 vNormal;\r\nvarying vec2 vUv;\r\n\r\nuniform vec3 ambientLightColor;\r\n\r\n#if MAX_DIR_LIGHTS > 0\r\n\r\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\r\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\r\n\r\n#endif\r\n\r\n#if MAX_HEMI_LIGHTS > 0\r\n\r\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\r\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\r\n\tuniform vec3 hemisphereLightPosition[ MAX_HEMI_LIGHTS ];\r\n\r\n#endif\r\n\r\n#if MAX_POINT_LIGHTS > 0\r\n\r\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\r\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\r\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\r\n\r\n#endif\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n[*]\r\n\r\n// Fresnel term\r\n\r\nfloat fresnelReflectance( vec3 H, vec3 V, float F0 ) {\r\n\r\n\tfloat base = 1.0 - dot( V, H );\r\n\tfloat exponential = pow( base, 5.0 );\r\n\r\n\treturn exponential + F0 * ( 1.0 - exponential );\r\n\r\n}\r\n\r\n// Kelemen/Szirmay-Kalos specular BRDF\r\n\r\nfloat KS_Skin_Specular( vec3 N, \t\t// Bumped surface normal\r\n\t\t\t\t\t\tvec3 L, \t\t// Points to light\r\n\t\t\t\t\t\tvec3 V, \t\t// Points to eye\r\n\t\t\t\t\t\tfloat m,  \t// Roughness\r\n\t\t\t\t\t\tfloat rho_s \t// Specular brightness\r\n\t\t\t\t\t\t) {\r\n\r\n\tfloat result = 0.0;\r\n\tfloat ndotl = dot( N, L );\r\n\r\n\tif( ndotl > 0.0 ) {\r\n\r\n\t\tvec3 h = L + V; // Unnormalized half-way vector\r\n\t\tvec3 H = normalize( h );\r\n\r\n\t\tfloat ndoth = dot( N, H );\r\n\r\n\t\tfloat PH = pow( 2.0 * texture2D( tBeckmann, vec2( ndoth, m ) ).x, 10.0 );\r\n\r\n\t\tfloat F = fresnelReflectance( H, V, 0.028 );\r\n\t\tfloat frSpec = max( PH * F / dot( h, h ), 0.0 );\r\n\r\n\t\tresult = ndotl * rho_s * frSpec; // BRDF * dot(N,L) * rho_s\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n\tgl_FragColor = vec4( vec3( 1.0 ), uOpacity );\r\n\r\n\tvec4 colDiffuse = texture2D( tDiffuse, vUv );\r\n\tcolDiffuse.rgb *= colDiffuse.rgb;\r\n\r\n\tgl_FragColor = gl_FragColor * colDiffuse;\r\n\r\n\tvec3 normal = normalize( vNormal );\r\n\tvec3 viewPosition = normalize( vViewPosition );\r\n\r\n\tfloat specularStrength;\r\n\r\n\tif ( enableSpecular ) {\r\n\r\n\t\tvec4 texelSpecular = texture2D( specularMap, vUv );\r\n\t\tspecularStrength = texelSpecular.r;\r\n\r\n\t} else {\r\n\r\n\t\tspecularStrength = 1.0;\r\n\r\n\t}\r\n\r\n\t#ifdef USE_BUMPMAP\r\n\r\n\t\tif ( enableBump ) normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\r\n\r\n\t#endif\r\n\r\n\t// point lights\r\n\r\n\tvec3 specularTotal = vec3( 0.0 );\r\n\r\n\t#if MAX_POINT_LIGHTS > 0\r\n\r\n\t\tvec3 pointTotal = vec3( 0.0 );\r\n\r\n\t\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\r\n\r\n\t\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\r\n\r\n\t\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\r\n\r\n\t\t\tfloat lDistance = 1.0;\r\n\r\n\t\t\tif ( pointLightDistance[ i ] > 0.0 )\r\n\t\t\t\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\r\n\r\n\t\t\tlVector = normalize( lVector );\r\n\r\n\t\t\tfloat pointDiffuseWeightFull = max( dot( normal, lVector ), 0.0 );\r\n\t\t\tfloat pointDiffuseWeightHalf = max( 0.5 * dot( normal, lVector ) + 0.5, 0.0 );\r\n\t\t\tvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), uWrapRGB );\r\n\r\n\t\t\tfloat pointSpecularWeight = KS_Skin_Specular( normal, lVector, viewPosition, uRoughness, uSpecularBrightness );\r\n\r\n\t\t\tpointTotal    += lDistance * uDiffuseColor * pointLightColor[ i ] * pointDiffuseWeight;\r\n\t\t\tspecularTotal += lDistance * uSpecularColor * pointLightColor[ i ] * pointSpecularWeight * specularStrength;\r\n\r\n\t\t}\r\n\r\n\t#endif\r\n\r\n\t// directional lights\r\n\t\t\t\t\r\n\t#if MAX_DIR_LIGHTS > 0\r\n\r\n\t\tvec3 dirTotal = vec3( 0.0 );\r\n\r\n\t\tfor( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\r\n\r\n\t\t\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\r\n\r\n\t\t\tvec3 dirVector = normalize( lDirection.xyz );\r\n\r\n\t\t\tfloat dirDiffuseWeightFull = max( dot( normal, dirVector ), 0.0 );\r\n\t\t\tfloat dirDiffuseWeightHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\r\n\t\t\tvec3 dirDiffuseWeight = mix( vec3 ( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), uWrapRGB );\r\n\r\n\t\t\tfloat dirSpecularWeight =  KS_Skin_Specular( normal, dirVector, viewPosition, uRoughness, uSpecularBrightness );\r\n\r\n\t\t\tdirTotal \t   += uDiffuseColor * directionalLightColor[ i ] * dirDiffuseWeight;\r\n\t\t\tspecularTotal += uSpecularColor * directionalLightColor[ i ] * dirSpecularWeight * specularStrength;\r\n\r\n\t\t}\r\n\r\n\t#endif\r\n\r\n\t// hemisphere lights\r\n\r\n\t#if MAX_HEMI_LIGHTS > 0\r\n\r\n\t\tvec3 hemiTotal = vec3( 0.0 );\r\n\r\n\t\tfor ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\r\n\r\n\t\t\tvec4 lPosition = viewMatrix * vec4( hemisphereLightPosition[ i ], 1.0 );\r\n\t\t\tvec3 lVector = normalize( lPosition.xyz + vViewPosition.xyz );\r\n\r\n\t\t\tfloat dotProduct = dot( normal, lVector );\r\n\t\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\r\n\r\n\t\t\themiTotal += uDiffuseColor * mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\r\n\r\n\t\t\t// specular (sky light)\r\n\r\n\t\t\tfloat hemiSpecularWeight = 0.0;\r\n\t\t\themiSpecularWeight += KS_Skin_Specular( normal, lVector, viewPosition, uRoughness, uSpecularBrightness );\r\n\r\n\t\t\t// specular (ground light)\r\n\r\n\t\t\tvec3 lVectorGround = normalize( -lPosition.xyz + vViewPosition.xyz );\r\n\t\t\themiSpecularWeight += KS_Skin_Specular( normal, lVectorGround, viewPosition, uRoughness, uSpecularBrightness );\r\n\r\n\t\t\tspecularTotal += uSpecularColor * mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight ) * hemiSpecularWeight * specularStrength;\r\n\r\n\t\t}\r\n\r\n\t#endif\r\n\r\n\t// all lights contribution summation\r\n\r\n\tvec3 totalLight = vec3( 0.0 );\r\n\r\n\t#if MAX_DIR_LIGHTS > 0\r\n\t\ttotalLight += dirTotal;\r\n\t#endif\r\n\r\n\t#if MAX_POINT_LIGHTS > 0\r\n\t\ttotalLight += pointTotal;\r\n\t#endif\r\n\r\n\t#if MAX_HEMI_LIGHTS > 0\r\n\t\ttotalLight += hemiTotal;\r\n\t#endif\r\n\r\n\tgl_FragColor.xyz = gl_FragColor.xyz * ( totalLight + ambientLightColor * uAmbientColor ) + specularTotal;\r\n\r\n[*]\r\n\r\n}'};_=cec.prototype=bec.prototype=new Kb;_.gC=function dec(){return TH};_.ac=function eec(){return 'uniform vec4 offsetRepeat;\r\n\r\nvarying vec3 vNormal;\r\nvarying vec2 vUv;\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n[*]\r\n\r\nvoid main() {\r\n\r\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\r\n\tvec4 mPosition = modelMatrix * vec4( position, 1.0 );\r\n\r\n\tvViewPosition = -mvPosition.xyz;\r\n\r\n\tvNormal = normalMatrix * normal;\r\n\r\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\r\n\r\n\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n[*]\r\n\r\n}\r\n'};var nG=p4(Wlc,'MaterialsBumpmapSkin$DemoScene'),mG=p4(Wlc,'MaterialsBumpmapSkin$DemoScene$1'),QH=p4(Zlc,'BeckmannShader'),PH=p4(Zlc,'BeckmannShader_Resources_default_InlineClientBundleGenerator'),NH=p4(Zlc,'BeckmannShader_Resources_default_InlineClientBundleGenerator$1'),OH=p4(Zlc,'BeckmannShader_Resources_default_InlineClientBundleGenerator$2'),VH=p4(Zlc,'SkinSimpleShader'),UH=p4(Zlc,'SkinSimpleShader_Resources_default_InlineClientBundleGenerator'),SH=p4(Zlc,'SkinSimpleShader_Resources_default_InlineClientBundleGenerator$1'),TH=p4(Zlc,'SkinSimpleShader_Resources_default_InlineClientBundleGenerator$2');sic(ge)(21);